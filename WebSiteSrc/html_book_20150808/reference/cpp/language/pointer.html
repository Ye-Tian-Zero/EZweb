<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html lang="en" dir="ltr" class="client-nojs">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Pointer declaration - cppreference.com</title>
<meta charset="UTF-8">
<meta name="generator" content="MediaWiki 1.21.2">


<link rel="shortcut icon" href="../../../favicon.ico">



<link rel="stylesheet" href="../../../common/ext.css">
<meta name="ResourceLoaderDynamicStyles" content="">
<link rel="stylesheet" href="../../../common/site_modules.css">
<style>a:lang(ar),a:lang(ckb),a:lang(fa),a:lang(kk-arab),a:lang(mzn),a:lang(ps),a:lang(ur){text-decoration:none}#toc{display:none}.editsection{display:none}
/* cache key: mwiki1-mwiki_en_:resourceloader:filter:minify-css:7:472787eddcf4605d11de8c7ef047234f */</style>

<script src="../../../common/startup_scripts.js"></script>
<script>if(window.mw){
mw.config.set({"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"cpp/language/pointer","wgTitle":"cpp/language/pointer","wgCurRevisionId":73560,"wgArticleId":5596,"wgIsArticle":true,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":[],"wgBreakFrames":false,"wgPageContentLanguage":"en","wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgMonthNamesShort":["","Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"wgRelevantPageName":"cpp/language/pointer","wgRestrictionEdit":[],"wgRestrictionMove":[]});
}</script><script>if(window.mw){
mw.loader.implement("user.options",function(){mw.user.options.set({"ccmeonemails":0,"cols":80,"date":"default","diffonly":0,"disablemail":0,"disablesuggest":0,"editfont":"default","editondblclick":0,"editsection":0,"editsectiononrightclick":0,"enotifminoredits":0,"enotifrevealaddr":0,"enotifusertalkpages":1,"enotifwatchlistpages":0,"extendwatchlist":0,"externaldiff":0,"externaleditor":0,"fancysig":0,"forceeditsummary":0,"gender":"unknown","hideminor":0,"hidepatrolled":0,"imagesize":2,"justify":0,"math":1,"minordefault":0,"newpageshidepatrolled":0,"nocache":0,"noconvertlink":0,"norollbackdiff":0,"numberheadings":0,"previewonfirst":0,"previewontop":1,"quickbar":5,"rcdays":7,"rclimit":50,"rememberpassword":0,"rows":25,"searchlimit":20,"showhiddencats":0,"showjumplinks":1,"shownumberswatching":1,"showtoc":0,"showtoolbar":1,"skin":"cppreference2","stubthreshold":0,"thumbsize":2,"underline":2,"uselivepreview":0,"usenewrc":0,"watchcreations":0,"watchdefault":0,"watchdeletion":0,
"watchlistdays":3,"watchlisthideanons":0,"watchlisthidebots":0,"watchlisthideliu":0,"watchlisthideminor":0,"watchlisthideown":0,"watchlisthidepatrolled":0,"watchmoves":0,"wllimit":250,"variant":"en","language":"en","searchNs0":true,"searchNs1":false,"searchNs2":false,"searchNs3":false,"searchNs4":false,"searchNs5":false,"searchNs6":false,"searchNs7":false,"searchNs8":false,"searchNs9":false,"searchNs10":false,"searchNs11":false,"searchNs12":false,"searchNs13":false,"searchNs14":false,"searchNs15":false,"gadget-ColiruCompiler":1});;},{},{});mw.loader.implement("user.tokens",function(){mw.user.tokens.set({"editToken":"+\\","patrolToken":false,"watchToken":false});;},{},{});
/* cache key: mwiki1-mwiki_en_:resourceloader:filter:minify-js:7:ca03345b1e2c4d90a25d968753a73b92 */
}</script>
<script>if(window.mw){
mw.loader.load(["mediawiki.page.startup","mediawiki.legacy.wikibits","mediawiki.legacy.ajax"]);
}</script>
<style type="text/css">/*<![CDATA[*/
.source-cpp {line-height: normal;}
.source-cpp li, .source-cpp pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for cpp
 * CSS class: source-cpp, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie, 2007 - 2008 Benny Baumann
 * (http://qbnz.com/highlighter/ and http://geshi.org/)
 * --------------------------------------
 */
.cpp.source-cpp .de1, .cpp.source-cpp .de2 {font: normal normal 1em/1.2em monospace; margin:0; padding:0; background:none; vertical-align:top;}
.cpp.source-cpp  {font-family:monospace;}
.cpp.source-cpp .imp {font-weight: bold; color: red;}
.cpp.source-cpp li, .cpp.source-cpp .li1 {font-weight: normal; vertical-align:top;}
.cpp.source-cpp .ln {width:1px;text-align:right;margin:0;padding:0 2px;vertical-align:top;}
.cpp.source-cpp .li2 {font-weight: bold; vertical-align:top;}
.cpp.source-cpp .kw1 {color: #0000dd;}
.cpp.source-cpp .kw2 {color: #0000ff;}
.cpp.source-cpp .kw3 {color: #0000dd;}
.cpp.source-cpp .kw4 {color: #0000ff;}
.cpp.source-cpp .co1 {color: #909090;}
.cpp.source-cpp .co2 {color: #339900;}
.cpp.source-cpp .coMULTI {color: #ff0000; font-style: italic;}
.cpp.source-cpp .es0 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es1 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es2 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es3 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es4 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es5 {color: #008000; font-weight: bold;}
.cpp.source-cpp .br0 {color: #008000;}
.cpp.source-cpp .sy0 {color: #008000;}
.cpp.source-cpp .sy1 {color: #000080;}
.cpp.source-cpp .sy2 {color: #000040;}
.cpp.source-cpp .sy3 {color: #000040;}
.cpp.source-cpp .sy4 {color: #008080;}
.cpp.source-cpp .st0 {color: #008000;}
.cpp.source-cpp .nu0 {color: #000080;}
.cpp.source-cpp .nu6 {color: #000080;}
.cpp.source-cpp .nu8 {color: #000080;}
.cpp.source-cpp .nu12 {color: #000080;}
.cpp.source-cpp .nu16 {color:#000080;}
.cpp.source-cpp .nu17 {color:#000080;}
.cpp.source-cpp .nu18 {color:#000080;}
.cpp.source-cpp .nu19 {color:#000080;}
.cpp.source-cpp .ln-xtra, .cpp.source-cpp li.ln-xtra, .cpp.source-cpp div.ln-xtra {background-color: #ffc;}
.cpp.source-cpp span.xtra { display:block; }

/*]]>*/
</style>
<style type="text/css">/*<![CDATA[*/
.source-text {line-height: normal;}
.source-text li, .source-text pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for text
 * CSS class: source-text, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie, 2007 - 2008 Benny Baumann
 * (http://qbnz.com/highlighter/ and http://geshi.org/)
 * --------------------------------------
 */
.text.source-text .de1, .text.source-text .de2 {font: normal normal 1em/1.2em monospace; margin:0; padding:0; background:none; vertical-align:top;}
.text.source-text  {font-family:monospace;}
.text.source-text .imp {font-weight: bold; color: red;}
.text.source-text li, .text.source-text .li1 {font-weight: normal; vertical-align:top;}
.text.source-text .ln {width:1px;text-align:right;margin:0;padding:0 2px;vertical-align:top;}
.text.source-text .li2 {font-weight: bold; vertical-align:top;}
.text.source-text .ln-xtra, .text.source-text li.ln-xtra, .text.source-text div.ln-xtra {background-color: #ffc;}
.text.source-text span.xtra { display:block; }

/*]]>*/
</style>
<!--[if lt IE 7]><style type="text/css">body{behavior:url("/mwiki/skins/cppreference2/csshover.min.htc")}</style><![endif]-->
</head>
<body class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-cpp_language_pointer skin-cppreference2 action-view cpp-navbar">
        <!-- header -->
        
        <!-- /header -->
        <!-- content -->
        <div id="cpp-content-base">
            <div id="content">
                <a id="top"></a>
                <div id="mw-js-message" style="display:none;"></div>
                                <!-- firstHeading -->
                <h1 id="firstHeading" class="firstHeading">Pointer declaration</h1>
                <!-- /firstHeading -->
                <!-- bodyContent -->
                <div id="bodyContent">
                                        <!-- tagline -->
                    <div id="siteSub">From cppreference.com</div>
                    <!-- /tagline -->
                                        <!-- subtitle -->
                    <div id="contentSub"><span class="subpages">&lt; <a href="../../cpp.html" title="cpp">cpp</a>‎ | <a href="../language.1.html" title="cpp/language">language</a></span></div>
                    <!-- /subtitle -->
                                                            <!-- bodycontent -->
                    <div id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr">
<div class="t-navbar" style="">
<div class="t-navbar-sep"> </div>
<div class="t-navbar-head">
<a href="../../cpp.html" title="cpp"> C++</a><div class="t-navbar-menu"><div>
<div><table class="t-nv-begin" cellpadding="0" style="line-height:1.1em;">
<tr class="t-nv"><td colspan="5"> <a href="../language.1.html" title="cpp/language"> Language</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../header.html" title="cpp/header"> Standard library headers</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../concept.html" title="cpp/concept"> Concepts</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../utility.html" title="cpp/utility"> Utilities library</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../string.html" title="cpp/string"> Strings library</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../container.html" title="cpp/container"> Containers library</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../algorithm.html" title="cpp/algorithm"> Algorithms library</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../iterator.html" title="cpp/iterator"> Iterators library</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../numeric.html" title="cpp/numeric"> Numerics library</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../io.html" title="cpp/io"> Input/output library</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../locale.html" title="cpp/locale"> Localizations library</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../regex.html" title="cpp/regex"> Regular expressions library</a> <span class="t-mark-rev t-since-cxx11">(C++11)</span> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../atomic.html" title="cpp/atomic"> Atomic operations library</a> <span class="t-mark-rev t-since-cxx11">(C++11)</span> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../thread.html" title="cpp/thread"> Thread support library</a> <span class="t-mark-rev t-since-cxx11">(C++11)</span> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../experimental.html" title="cpp/experimental"> Technical Specifications</a> </td></tr>
</table></div>
<div></div>
</div></div>
</div>
<div class="t-navbar-sep"> </div>
<div class="t-navbar-head"><a href="../language.1.html" title="cpp/language"> C++ language</a></div>
<div class="t-navbar-sep"> </div>
<div class="t-navbar-head">
<a href="declarations.html" title="cpp/language/declarations"> Declarations</a><div class="t-navbar-menu"><div>
<div style="display:inline-block">
<div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv-col-table">
<td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv-h2"><td colspan="5"> Overview </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="declarations.html" title="cpp/language/declarations"> declaration syntax</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="declarations.html#Specifiers" title="cpp/language/declarations"> decl-specifier-seq</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="declarations.html#Declarators" title="cpp/language/declarations"> declarator</a> </td></tr>
<tr class="t-nv-h2"><td colspan="5"> Specifiers </td></tr>
<tr class="t-nv"><td colspan="5"><div class="t-nv-ln-table"><div><a href="typedef.html" title="cpp/language/typedef"><span class="t-lines"><span>typedef</span></span></a></div></div></td></tr>
<tr class="t-nv"><td colspan="5"> <a href="inline.html" title="cpp/language/inline"> inline function specifier</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="virtual.html" title="cpp/language/virtual"> virtual function specifier</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="explicit.html" title="cpp/language/explicit"> explicit function specifier</a> </td></tr>
<tr class="t-nv"><td colspan="5"><div class="t-nv-ln-table"><div><a href="friend.html" title="cpp/language/friend"><span class="t-lines"><span>friend</span></span></a></div></div></td></tr>
<tr class="t-nv"><td colspan="5"><div class="t-nv-ln-table">
<div><a href="constexpr.html" title="cpp/language/constexpr"><span class="t-lines"><span>constexpr</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div>
</div></td></tr>
<tr class="t-nv"><td colspan="5"> <a href="storage_duration.html" title="cpp/language/storage duration"> storage class specifiers</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="class.html" title="cpp/language/class"> class </a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="union.html" title="cpp/language/union"> union </a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="enum.html" title="cpp/language/enum"> enum </a> </td></tr>
<tr class="t-nv"><td colspan="5"><div class="t-nv-ln-table">
<div><a href="decltype.html" title="cpp/language/decltype"><span class="t-lines"><span>decltype</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div>
</div></td></tr>
<tr class="t-nv"><td colspan="5"><div class="t-nv-ln-table">
<div><a href="auto.html" title="cpp/language/auto"><span class="t-lines"><span>auto</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div>
</div></td></tr>
<tr class="t-nv"><td colspan="5"><div class="t-nv-ln-table">
<div><a href="alignas.html" title="cpp/language/alignas"><span class="t-lines"><span>alignas</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div>
</div></td></tr>
<tr class="t-nv"><td colspan="5"><div class="t-nv-ln-table"><div><a href="cv.html" title="cpp/language/cv"><span class="t-lines"><span>const/volatile</span></span></a></div></div></td></tr>
<tr class="t-nv"><td colspan="5"> <a href="elaborated_type_specifier.html" title="cpp/language/elaborated type specifier"> elaborated type specifier</a>
</td></tr>
<tr class="t-nv"><td colspan="5"> <a href="attributes.html" title="cpp/language/attributes"> attributes </a><span class="t-mark-rev t-since-cxx11">(C++11)</span> </td></tr>
<tr class="t-nv-h2"><td colspan="5"> Declarators </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="reference.html" title="cpp/language/reference"> reference </a> </td></tr>
<tr class="t-nv"><td colspan="5"> <strong class="selflink"> pointer </strong> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="array.html" title="cpp/language/array"> array </a> </td></tr>
</table></div></td>
<td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv-h2"><td colspan="5"> Block declarations </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="declarations.html" title="cpp/language/declarations"> simple-declaration</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="type_alias.html" title="cpp/language/type alias"> alias declaration</a><span class="t-mark-rev t-since-cxx11">(C++11)</span> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="namespace_alias.html" title="cpp/language/namespace alias"> namespace alias definition </a>
</td></tr>
<tr class="t-nv"><td colspan="5"> <a href="using_declaration.html" title="cpp/language/using declaration"> using-declaration</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="namespace.html#Using-directives" title="cpp/language/namespace"> using-directive</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="static_assert.html" title="cpp/language/static assert"> static_assert declaration</a> <span class="t-mark-rev t-since-cxx11">(C++11)</span>
</td></tr>
<tr class="t-nv"><td colspan="5"> <a href="asm.html" title="cpp/language/asm"> asm-definition</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="enum.html" title="cpp/language/enum"> opaque enum declaration</a><span class="t-mark-rev t-since-cxx11">(C++11)</span> </td></tr>
<tr class="t-nv-h2"><td colspan="5"> Other declarations </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="namespace.html" title="cpp/language/namespace"> namespace definition</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="function.html" title="cpp/language/function"> function declaration</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="class_template.html" title="cpp/language/class template"> class template declaration</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="function_template.html" title="cpp/language/function template"> function template declaration</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="class_template.html#Explicit_instantiation" title="cpp/language/class template"> explicit template instantiation</a><span class="t-mark-rev t-since-cxx11">(C++11)</span>
</td></tr>
<tr class="t-nv"><td colspan="5"> <a href="template_specialization.html" title="cpp/language/template specialization"> explicit template specialization</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="language_linkage.html" title="cpp/language/language linkage"> linkage specification</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="declarations.html" title="cpp/language/declarations"> attribute declaration</a> <span class="t-mark-rev t-since-cxx11">(C++11)</span> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="declarations.html" title="cpp/language/declarations"> empty declaration</a> </td></tr>
</table></div></td>
</tr>
</table></div>
</div>
<div></div>
</div></div>
</div>
<div class="t-navbar-sep"> </div>
</div>
<p>Declares a variable of a pointer or pointer-to-member type.
</p>
<table id="toc" class="toc"><tr><td>
<div id="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1 tocsection-1">
<a href="pointer.html#Syntax"><span class="tocnumber">1</span> <span class="toctext">Syntax</span></a>
<ul>
<li class="toclevel-2 tocsection-2"><a href="pointer.html#Pointers_to_objects"><span class="tocnumber">1.1</span> <span class="toctext">Pointers to objects</span></a></li>
<li class="toclevel-2 tocsection-3"><a href="pointer.html#Pointers_to_functions"><span class="tocnumber">1.2</span> <span class="toctext">Pointers to functions</span></a></li>
<li class="toclevel-2 tocsection-4"><a href="pointer.html#Pointers_to_data_members"><span class="tocnumber">1.3</span> <span class="toctext">Pointers to data members</span></a></li>
<li class="toclevel-2 tocsection-5"><a href="pointer.html#Pointers_to_member_functions"><span class="tocnumber">1.4</span> <span class="toctext">Pointers to member functions</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-6"><a href="pointer.html#Pointers_to_void"><span class="tocnumber">2</span> <span class="toctext">Pointers to void</span></a></li>
<li class="toclevel-1 tocsection-7"><a href="pointer.html#Null_pointers"><span class="tocnumber">3</span> <span class="toctext">Null pointers</span></a></li>
<li class="toclevel-1 tocsection-8"><a href="pointer.html#Constness"><span class="tocnumber">4</span> <span class="toctext">Constness</span></a></li>
</ul>
</td></tr></table>
<h3>
<span class="editsection">[<a href="http%3A//en.cppreference.com/mwiki/index.php" title="Edit section: Syntax">edit</a>]</span> <span class="mw-headline" id="Syntax">Syntax</span>
</h3>
<p>A pointer declaration is any simple declaration whose <a href="declarations.html" title="cpp/language/declarations">declarator</a> has the form
</p>
<table class="t-sdsc-begin">

<tr>
<td colspan="10" class="t-sdsc-sep">
</td>
</tr>
<tr class="t-sdsc">
<td> <code><b>*</b></code> <span class="t-spar">attr</span><span class="t-mark">(optional)</span> <span class="t-spar">cv</span><span class="t-mark">(optional)</span> <span class="t-spar">declarator</span>
</td>
<td> (1)
</td>
<td class="t-sdsc-nopad">
</td>
</tr>



<tr>
<td colspan="10" class="t-sdsc-sep">
</td>
</tr>
<tr class="t-sdsc">
<td> <span class="t-spar">nested-name-specifier</span> <code><b>*</b></code> <span class="t-spar">attr</span><span class="t-mark">(optional)</span> <span class="t-spar">cv</span><span class="t-mark">(optional)</span> <span class="t-spar">declarator</span>
</td>
<td> (2)
</td>
<td class="t-sdsc-nopad">
</td>
</tr>



<tr>
<td colspan="10" class="t-sdsc-sep">
</td>
</tr>
</table>
<div class="t-li1">
<span class="t-li">1)</span> <b>Pointer declarator</b>: the declaration <span class="t-c"><span class="mw-geshi cpp source-cpp">S <span class="sy2">*</span> D<span class="sy4">;</span></span></span> declares <code>D</code> as a pointer to the type determined by <span class="t-spar">decl-specifier-seq</span> <code>S</code>.</div>
<div class="t-li1">
<span class="t-li">2)</span> <b>Pointer to member declarator</b>: the declaration <span class="t-c"><span class="mw-geshi cpp source-cpp">S C<span class="sy4">::</span><span class="sy2">*</span>D<span class="sy4">;</span></span></span> declares <code>D</code> as a pointer to member of <code>C</code> of type determined by <span class="t-spar">decl-specifier-seq</span> <code>S</code>.</div>
<table class="t-par-begin">


<tr class="t-par">
<td>  <span class="t-spar">declarator</span>
</td>
<td> -
</td>
<td>  any <a href="declarations.html" title="cpp/language/declarations">declarator</a> other than a reference declarator (there are no pointers to references). It can be another pointer declarator (pointer to pointers are allowed)
</td>
</tr>
<tr class="t-par">
<td>  <span class="t-spar">attr</span><span class="t-mark-rev t-since-cxx11">(C++11)</span>
</td>
<td> -
</td>
<td>  optional list of <a href="attributes.html" title="cpp/language/attributes">attributes</a>
</td>
</tr>
<tr class="t-par">
<td>  <span class="t-spar">cv</span>
</td>
<td> -
</td>
<td>  const/volatile qualification which apply to the pointer that is being declared (not to the pointed-to type, whose qualifications are part of <span class="t-spar">decl-specifier-seq</span>)
</td>
</tr>
<tr class="t-par">
<td>  <span class="t-spar">nested-name-specifier</span>
</td>
<td> -
</td>
<td>  a <a href="name.html#Qualified_identifiers" title="cpp/language/identifiers">sequence of names and scope resolution operators <code><b>::</b></code> </a>
</td>
</tr>
</table>
<p>There are no pointers to <a href="reference.html" title="cpp/language/reference">references</a> and there are no pointers to <a href="bit_field.html" title="cpp/language/bit field">bit fields</a>.
</p>
<h4>
<span class="editsection">[<a href="http%3A//en.cppreference.com/mwiki/index.php" title="Edit section: Pointers to objects">edit</a>]</span> <span class="mw-headline" id="Pointers_to_objects">Pointers to objects</span>
</h4>
<p>A pointer to object can be initialized with the return value of the <a href="operator_member_access.html" title="cpp/language/operator member access">address-of operator</a> applied to any expression of object type, including another pointer type:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw4">int</span> n<span class="sy4">;</span>
<span class="kw4">int</span><span class="sy2">*</span> np <span class="sy1">=</span> <span class="sy3">&amp;</span>n<span class="sy4">;</span> <span class="co1">// pointer to int</span>
<span class="kw4">int</span><span class="sy2">*</span> <span class="kw4">const</span> <span class="sy2">*</span> npp <span class="sy1">=</span> <span class="sy3">&amp;</span>np<span class="sy4">;</span> <span class="co1">// non-const pointer to const pointer to non-const int</span>
 
<span class="kw4">int</span> a<span class="br0">[</span><span class="nu0">2</span><span class="br0">]</span><span class="sy4">;</span>
<span class="kw4">int</span> <span class="br0">(</span><span class="sy2">*</span>ap<span class="br0">)</span><span class="br0">[</span><span class="nu0">2</span><span class="br0">]</span> <span class="sy1">=</span> <span class="sy3">&amp;</span>a<span class="sy4">;</span> <span class="co1">// pointer to array of int</span>
 
<span class="kw1">struct</span> S <span class="br0">{</span> <span class="kw4">int</span> n<span class="sy4">;</span> <span class="br0">}</span><span class="sy4">;</span>
S s <span class="sy1">=</span> <span class="br0">{</span><span class="nu0">1</span><span class="br0">}</span><span class="sy4">;</span>
<span class="kw4">int</span><span class="sy2">*</span> sp <span class="sy1">=</span> <span class="sy3">&amp;</span>s.<span class="me1">n</span><span class="sy4">;</span> <span class="co1">// pointer to the int that is a member of s</span></pre></div></div>
<p>Pointers may appear as operands to the built-in indirection operator (unary <code>operator*</code>), which returns <a href="value_category.html" title="cpp/language/value category">the lvalue</a> identifying the pointed-to object:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw4">int</span> n<span class="sy4">;</span>
<span class="kw4">int</span><span class="sy2">*</span> p <span class="sy1">=</span> <span class="sy3">&amp;</span>n<span class="sy4">;</span>     <span class="co1">// pointer p is pointing to n</span>
<span class="kw4">int</span><span class="sy3">&amp;</span> ref <span class="sy1">=</span> <span class="sy2">*</span>p<span class="sy4">;</span>   <span class="co1">// the lvalue expression that identifies n is bound to a reference</span>
ref <span class="sy1">=</span> <span class="nu0">7</span><span class="sy4">;</span>         <span class="co1">// stores 7 in n</span>
<a href="../io/cout.html"><span class="kw1446">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="sy2">*</span>p<span class="sy4">;</span> <span class="co1">// lvalue-to-rvalue conversion reads the value from n</span></pre></div></div>
<p>Pointers to class objects may also appear as the left-hand operands of the member access through pointer operators <a href="operator_member_access.html#Built-in_member_access_operators" title="cpp/language/operator member access">operator-&gt;</a> and <a href="operator_member_access.html#Built-in_pointer-to-member_access_operators" title="cpp/language/operator member access">operator-&gt;*</a>
</p>
<p>Because of the <a href="implicit_cast.html" title="cpp/language/implicit cast">array-to-pointer</a> implicit conversion, pointer to the first element of an array can be initialized with an expression of array type:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw4">int</span> a<span class="br0">[</span><span class="nu0">2</span><span class="br0">]</span><span class="sy4">;</span>
<span class="kw4">int</span> <span class="sy2">*</span>p <span class="sy1">=</span> a<span class="sy4">;</span> <span class="co1">// pointer to a[0]</span>
 
<span class="kw4">int</span> b<span class="br0">[</span><span class="nu0">3</span><span class="br0">]</span><span class="br0">[</span><span class="nu0">3</span><span class="br0">]</span><span class="sy4">;</span>
<span class="kw4">int</span> <span class="br0">(</span><span class="sy2">*</span>row<span class="br0">)</span><span class="br0">[</span><span class="nu0">3</span><span class="br0">]</span> <span class="sy1">=</span> b<span class="sy4">;</span> <span class="co1">// pointer to b[0]</span></pre></div></div>
<p>Because of the derived-to-base <a href="implicit_cast.html" title="cpp/language/implicit cast">implicit conversion</a> for pointers, pointer to a base class can be initialized with the address of a derived class.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">struct</span> Base <span class="br0">{</span><span class="br0">}</span><span class="sy4">;</span>
<span class="kw1">struct</span> Derived <span class="sy4">:</span> Base <span class="br0">{</span><span class="br0">}</span><span class="sy4">;</span>
 
Derived d<span class="sy4">;</span>
Base<span class="sy2">*</span> p <span class="sy1">=</span> <span class="sy3">&amp;</span>d<span class="sy4">;</span></pre></div></div>
<p>If <code>Derived</code> is <a href="objects.html#Polymorphic_objects" title="cpp/language/object">polymorphic</a>, such pointer may be used to make <a href="virtual.html" title="cpp/language/virtual">virtual function calls</a>.
</p>
<p>Certain <a href="operator_arithmetic.html#Additive_operators" title="cpp/language/operator arithmetic">addition, subtraction</a>, <a href="operator_incdec.html" title="cpp/language/operator incdec">increment, and decrement</a> operators are defined for pointers to elements of arrays: such pointers satisfy the <a href="../concept/RandomAccessIterator.html" title="cpp/concept/RandomAccessIterator"><code>RandomAccessIterator</code></a> requirements and allow the C++ library <a href="../algorithm.html" title="cpp/algorithm">algorithms</a> to work with raw arrays.
</p>
<p><a href="operator_comparison.html#Pointer_comparison_operators" title="cpp/language/operator comparison">Comparison operators</a> are defined for pointers to objects in some situations: two pointers that represent the same address compare equal, two null pointer values compare equal, pointers to elements of the same array compare the same as the array indexes of those elements, and pointers to non-static class members with the same <a href="access.html" title="cpp/language/access">member access</a> compare in order of declaration of those class members.
</p>
<p>Many implementations also provide <a href="http%3A//en.wikipedia.com/wiki/Total_order#Strict_total_order" class="extiw" title="enwiki:Total order">strict total ordering</a> of pointers of random origin, e.g. if they are implemented as addresses within continuous virtual address space. Those implementations that do not (e.g. where not all bits of the pointer are part of a memory address and have to be ignored for comparison, or an additional calculation is required or otherwise pointer and integer is not a 1 to 1 relationship), provide a specialization of <span class="t-lc"><a href="../utility/functional/less.html" title="cpp/utility/functional/less">std::less</a></span> for pointers that has that guarantee. This makes it possible to use all pointers of random origin as keys in standard associative containers such as <span class="t-lc"><a href="../container/set.html" title="cpp/container/set">std::set</a></span> or <span class="t-lc"><a href="../container/map.html" title="cpp/container/map">std::map</a></span>.
</p>
<h4>
<span class="editsection">[<a href="http%3A//en.cppreference.com/mwiki/index.php" title="Edit section: Pointers to functions">edit</a>]</span> <span class="mw-headline" id="Pointers_to_functions">Pointers to functions</span>
</h4>
<p>A pointer to function can be initialized with an address of a non-member function or a static member function. Because of the <a href="implicit_cast.html" title="cpp/language/implicit cast">function-to-pointer</a> conversion, the address-of operator is optional:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw4">void</span> f<span class="br0">(</span><span class="kw4">int</span><span class="br0">)</span><span class="sy4">;</span>
<span class="kw4">void</span> <span class="br0">(</span><span class="sy2">*</span>pf1<span class="br0">)</span><span class="br0">(</span><span class="kw4">int</span><span class="br0">)</span> <span class="sy1">=</span> <span class="sy3">&amp;</span>f<span class="sy4">;</span>
<span class="kw4">void</span> <span class="br0">(</span><span class="sy2">*</span>pf2<span class="br0">)</span><span class="br0">(</span><span class="kw4">int</span><span class="br0">)</span> <span class="sy1">=</span> f<span class="sy4">;</span> <span class="co1">// same as &amp;f</span></pre></div></div>
<p>Unlike functions or references to functions, pointers to functions are objects and thus can be stored in arrays, copied, assigned, etc.
</p>
<p>A pointer to function can be used on the left-hand side of the <a href="operator_other.html" title="cpp/language/operator other">function call operator</a>, this invokes the pointed-to function.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="co2">#include &lt;iostream&gt;</span>
 
<span class="kw4">int</span> f<span class="br0">(</span><span class="kw4">int</span> n<span class="br0">)</span>
<span class="br0">{</span>
    <a href="../io/cout.html"><span class="kw1446">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> n <span class="sy1">&lt;&lt;</span> <span class="st0">'<span class="es1">\n</span>'</span><span class="sy4">;</span>
    <span class="kw1">return</span> n<span class="sy2">*</span>n<span class="sy4">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw4">int</span> <span class="br0">(</span><span class="sy2">*</span>p<span class="br0">)</span><span class="br0">(</span><span class="kw4">int</span><span class="br0">)</span> <span class="sy1">=</span> f<span class="sy4">;</span>
    <span class="kw4">int</span> x <span class="sy1">=</span> p<span class="br0">(</span><span class="nu0">7</span><span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span></pre></div></div>
<p>Dereferencing a function pointer yields the lvalue identifying the pointed-to function:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw4">int</span> f<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
<span class="kw4">int</span> <span class="br0">(</span><span class="sy2">*</span>p<span class="br0">)</span><span class="br0">(</span><span class="br0">)</span> <span class="sy1">=</span> f<span class="sy4">;</span>    <span class="co1">// pointer p is pointing to f</span>
<span class="kw4">int</span> <span class="br0">(</span><span class="sy3">&amp;</span>ref<span class="br0">)</span><span class="br0">(</span><span class="br0">)</span> <span class="sy1">=</span> <span class="sy2">*</span>p<span class="sy4">;</span> <span class="co1">// the lvalue that identifies f is bound to a reference</span>
ref<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>  <span class="co1">// function f invoked through lvalue reference</span>
<span class="br0">(</span><span class="sy2">*</span>p<span class="br0">)</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// function f invoked through the function lvalue</span>
p<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>    <span class="co1">// function f invoked directly through the pointer</span></pre></div></div>
<p>A pointer to function may be initialized from an overload set which may include functions, function template specializations, and function templates, if only one overload matches the type of the pointer (see <a href="overloaded_address.html" title="cpp/language/overloaded address">address of an overloaded function</a> for more detail)
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">typename</span> T<span class="sy1">&gt;</span> T f<span class="br0">(</span>T n<span class="br0">)</span> <span class="br0">{</span><span class="br0">}</span>
<span class="kw4">double</span> f<span class="br0">(</span><span class="kw4">double</span> n<span class="br0">)</span> <span class="br0">{</span><span class="br0">}</span>
 
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw4">int</span> <span class="br0">(</span><span class="sy2">*</span>p<span class="br0">)</span><span class="br0">(</span><span class="kw4">int</span><span class="br0">)</span> <span class="sy1">=</span> f<span class="sy4">;</span> <span class="co1">// instantiates and selects f&lt;int&gt;</span>
<span class="br0">}</span></pre></div></div>
<p><a href="operator_comparison.html#Pointer_comparison_operators" title="cpp/language/operator comparison">Equality comparison operators</a> are defined for pointers to functions (they compare equal if pointing to the same function).
</p>
<h4>
<span class="editsection">[<a href="http%3A//en.cppreference.com/mwiki/index.php" title="Edit section: Pointers to data members">edit</a>]</span> <span class="mw-headline" id="Pointers_to_data_members">Pointers to data members</span>
</h4>
<p>A pointer to non-static data member <code>m</code> which is a member of class <code>C</code> can be initialized with the expression <code>&amp;C::m</code> exactly. Expressions such as <code>&amp;(C::m)</code> or <code>&amp;m</code> inside C's member function do not form pointers to members.
</p>
<p>Such pointer may be used as the right-hand argument of the <a href="operator_member_access.html" title="cpp/language/operator member access">pointer-to-member access operators</a> <code>operator.*</code> and <code>operator-&gt;*</code>.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">struct</span> C <span class="br0">{</span>
    <span class="kw4">int</span> m<span class="sy4">;</span>
<span class="br0">}</span><span class="sy4">;</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw4">int</span> C<span class="sy4">::</span><span class="sy2">*</span>p <span class="sy1">=</span> <span class="sy3">&amp;</span>C<span class="sy4">::</span><span class="me2">m</span><span class="sy4">;</span> <span class="co1">// p points at member m of class C</span>
    C c <span class="sy1">=</span> <span class="br0">{</span><span class="nu0">7</span><span class="br0">}</span><span class="sy4">;</span>
    <a href="../io/cout.html"><span class="kw1446">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> c.<span class="sy2">*</span>p <span class="sy1">&lt;&lt;</span> <span class="st0">'<span class="es1">\n</span>'</span><span class="sy4">;</span> <span class="co1">// prints 7</span>
    C<span class="sy2">*</span> cptr <span class="sy1">=</span> <span class="sy3">&amp;</span>c<span class="sy4">;</span>
    cptr<span class="sy2">-</span><span class="sy1">&gt;</span>m <span class="sy1">=</span> <span class="nu0">10</span><span class="sy4">;</span>
    <a href="../io/cout.html"><span class="kw1446">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> cptr<span class="sy2">-</span><span class="sy1">&gt;</span><span class="sy2">*</span>p <span class="sy1">&lt;&lt;</span> <span class="st0">'<span class="es1">\n</span>'</span><span class="sy4">;</span> <span class="co1">// prints 10</span>
<span class="br0">}</span></pre></div></div>
<p>Pointer to member of a base class can be <a href="implicit_cast.html" title="cpp/language/implicit cast">implicitly converted</a> to pointer to the same member of a derived class.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">struct</span> Base <span class="br0">{</span>
    <span class="kw4">int</span> m<span class="sy4">;</span>
<span class="br0">}</span><span class="sy4">;</span>
<span class="kw1">struct</span> Derived <span class="sy4">:</span> Base <span class="br0">{</span>
<span class="br0">}</span><span class="sy4">;</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw4">int</span> Base<span class="sy4">::</span><span class="sy2">*</span> pb <span class="sy1">=</span> <span class="sy3">&amp;</span>Base<span class="sy4">::</span><span class="me2">m</span><span class="sy4">;</span>
    <span class="kw4">int</span> Derived<span class="sy4">::</span><span class="sy2">*</span> pd <span class="sy1">=</span> pb<span class="sy4">;</span>
    Derived d<span class="sy4">;</span>
    d.<span class="me1">m</span> <span class="sy1">=</span> <span class="nu0">1</span><span class="sy4">;</span>
    <a href="../io/cout.html"><span class="kw1446">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> d.<span class="sy2">*</span>pd <span class="sy1">&lt;&lt;</span> <span class="st0">' '</span> <span class="sy1">&lt;&lt;</span> d.<span class="sy2">*</span>pb <span class="sy1">&lt;&lt;</span> <span class="st0">'<span class="es1">\n</span>'</span><span class="sy4">;</span> <span class="co1">// prints 1 1</span>
<span class="br0">}</span></pre></div></div>
<p>Conversion in the opposite direction, from a pointer to member of a derived class to a pointer to member of an unambiguous non-virtual base class, is allowed with <a href="static_cast.html" title="cpp/language/static cast">static_cast</a> and <a href="explicit_cast.html" title="cpp/language/explicit cast">explicit cast</a>, even if the base class does not have that member (but the most-derived class does, when the pointer is used for access)
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">struct</span> Base <span class="br0">{</span>
<span class="br0">}</span><span class="sy4">;</span>
<span class="kw1">struct</span> Derived <span class="sy4">:</span> Base <span class="br0">{</span>
    <span class="kw4">int</span> m<span class="sy4">;</span>
<span class="br0">}</span><span class="sy4">;</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw4">int</span> Derived<span class="sy4">::</span><span class="sy2">*</span> pd <span class="sy1">=</span> <span class="sy3">&amp;</span>Derived<span class="sy4">::</span><span class="me2">m</span><span class="sy4">;</span>
    <span class="kw4">int</span> Base<span class="sy4">::</span><span class="sy2">*</span> pb <span class="sy1">=</span> <span class="kw1">static_cast</span><span class="sy1">&lt;</span><span class="kw4">int</span> Base<span class="sy4">::</span><span class="sy2">*</span><span class="sy1">&gt;</span><span class="br0">(</span>pd<span class="br0">)</span><span class="sy4">;</span>
 
    Derived d<span class="sy4">;</span>
    d.<span class="me1">m</span> <span class="sy1">=</span> <span class="nu0">7</span><span class="sy4">;</span>
    <a href="../io/cout.html"><span class="kw1446">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> d.<span class="sy2">*</span>pb <span class="sy1">&lt;&lt;</span> <span class="st0">'<span class="es1">\n</span>'</span><span class="sy4">;</span> <span class="co1">// OK: prints 7</span>
 
    Base b<span class="sy4">;</span>
    <a href="../io/cout.html"><span class="kw1446">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> b.<span class="sy2">*</span>pb <span class="sy1">&lt;&lt;</span> <span class="st0">'<span class="es1">\n</span>'</span><span class="sy4">;</span> <span class="co1">// undefined behavior</span>
<span class="br0">}</span></pre></div></div>
<p>The pointed-to type of a pointer-to-member may be a pointer-to-member itself: pointers to members can be multilevel, and can be cv-qualifed differently at every level. Mixed multi-level combinations of pointers and pointers to members are also allowed
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">struct</span> A <span class="br0">{</span>
    <span class="kw4">int</span> m<span class="sy4">;</span>
    <span class="co1">// const pointer to non-const member</span>
    <span class="kw4">int</span> A<span class="sy4">::</span><span class="sy2">*</span> <span class="kw4">const</span> p<span class="sy4">;</span>
<span class="br0">}</span><span class="sy4">;</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <span class="co1">// non-const pointer to member which is a const pointer to non-const member</span>
    <span class="kw4">int</span> A<span class="sy4">::</span><span class="sy2">*</span> <span class="kw4">const</span> A<span class="sy4">::</span><span class="sy2">*</span> p1 <span class="sy1">=</span> <span class="sy3">&amp;</span>A<span class="sy4">::</span><span class="me2">p</span><span class="sy4">;</span>
 
    <span class="kw4">const</span> A a <span class="sy1">=</span> <span class="br0">{</span><span class="nu0">1</span>, <span class="sy3">&amp;</span>A<span class="sy4">::</span><span class="me2">m</span><span class="br0">}</span><span class="sy4">;</span>
    <a href="../io/cout.html"><span class="kw1446">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> a.<span class="sy2">*</span><span class="br0">(</span>a.<span class="sy2">*</span>p1<span class="br0">)</span> <span class="sy1">&lt;&lt;</span> <span class="st0">'<span class="es1">\n</span>'</span><span class="sy4">;</span> <span class="co1">// prints 1</span>
 
    <span class="co1">// regular non-const pointer to a const pointer-to-member</span>
    <span class="kw4">int</span> A<span class="sy4">::</span><span class="sy2">*</span> <span class="kw4">const</span> <span class="sy2">*</span> p2 <span class="sy1">=</span> <span class="sy3">&amp;</span>a.<span class="me1">p</span><span class="sy4">;</span>
    <a href="../io/cout.html"><span class="kw1446">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> a.<span class="sy2">**</span>p2 <span class="sy1">&lt;&lt;</span> <span class="st0">'<span class="es1">\n</span>'</span><span class="sy4">;</span> <span class="co1">// prints 1</span>
<span class="br0">}</span></pre></div></div>
<h4>
<span class="editsection">[<a href="http%3A//en.cppreference.com/mwiki/index.php" title="Edit section: Pointers to member functions">edit</a>]</span> <span class="mw-headline" id="Pointers_to_member_functions">Pointers to member functions</span>
</h4>
<p>A pointer to non-static member function <code>f</code> which is a member of class <code>C</code> can be initialized with the expression <code>&amp;C::f</code> exactly. Expressions such as <code>&amp;(C::f)</code> or <code>&amp;f</code> inside C's member function do not form pointers to member functions.
</p>
<p>Such pointer may be used as the right-hand argument of the <a href="operator_member_access.html" title="cpp/language/operator member access">pointer-to-member access operators</a> <code>operator.*</code> and <code>operator-&gt;*</code>. <a href="value_category.html#Pending_member_function_call" title="cpp/language/value category">The resulting expression</a> can be used only as the left-hand operand of a function-call operator:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">struct</span> C <span class="br0">{</span>
    <span class="kw4">void</span> f<span class="br0">(</span><span class="kw4">int</span> n<span class="br0">)</span> <span class="br0">{</span> <a href="../io/cout.html"><span class="kw1446">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> n <span class="sy1">&lt;&lt;</span> <span class="st0">'<span class="es1">\n</span>'</span><span class="sy4">;</span> <span class="br0">}</span>
<span class="br0">}</span><span class="sy4">;</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw4">void</span> <span class="br0">(</span>C<span class="sy4">::</span><span class="sy2">*</span>p<span class="br0">)</span><span class="br0">(</span><span class="kw4">int</span><span class="br0">)</span> <span class="sy1">=</span> <span class="sy3">&amp;</span>C<span class="sy4">::</span><span class="me2">f</span><span class="sy4">;</span> <span class="co1">// p points at member f of class C</span>
    C c<span class="sy4">;</span>
    <span class="br0">(</span>c.<span class="sy2">*</span>p<span class="br0">)</span><span class="br0">(</span><span class="nu0">1</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// prints 1</span>
    C<span class="sy2">*</span> cptr <span class="sy1">=</span> <span class="sy3">&amp;</span>c<span class="sy4">;</span>
    <span class="br0">(</span>cptr<span class="sy2">-</span><span class="sy1">&gt;</span><span class="sy2">*</span>p<span class="br0">)</span><span class="br0">(</span><span class="nu0">2</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// prints 2</span>
<span class="br0">}</span></pre></div></div>
<p><br>
Pointer to member function of a base class can be <a href="implicit_cast.html" title="cpp/language/implicit cast">implicitly converted</a> to pointer to the same member function of a derived class.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">struct</span> Base <span class="br0">{</span>
    <span class="kw4">void</span> f<span class="br0">(</span><span class="kw4">int</span> n<span class="br0">)</span> <span class="br0">{</span> <a href="../io/cout.html"><span class="kw1446">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> n <span class="sy1">&lt;&lt;</span> <span class="st0">'<span class="es1">\n</span>'</span><span class="sy4">;</span> <span class="br0">}</span>
<span class="br0">}</span><span class="sy4">;</span>
<span class="kw1">struct</span> Derived <span class="sy4">:</span> Base <span class="br0">{</span>
<span class="br0">}</span><span class="sy4">;</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw4">void</span> <span class="br0">(</span>Base<span class="sy4">::</span><span class="sy2">*</span> pb<span class="br0">)</span><span class="br0">(</span><span class="kw4">int</span><span class="br0">)</span> <span class="sy1">=</span> <span class="sy3">&amp;</span>Base<span class="sy4">::</span><span class="me2">f</span><span class="sy4">;</span>
    <span class="kw4">void</span> <span class="br0">(</span>Derived<span class="sy4">::</span><span class="sy2">*</span> pd<span class="br0">)</span><span class="br0">(</span><span class="kw4">int</span><span class="br0">)</span> <span class="sy1">=</span> pb<span class="sy4">;</span>
    Derived d<span class="sy4">;</span>
    <span class="br0">(</span>d.<span class="sy2">*</span>pd<span class="br0">)</span><span class="br0">(</span><span class="nu0">1</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="br0">(</span>d.<span class="sy2">*</span>pb<span class="br0">)</span><span class="br0">(</span><span class="nu0">2</span><span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span></pre></div></div>
<p>Conversion in the opposite direction, from a pointer to member function of a derived class to a pointer to member function of an unambiguous non-virtual base class, is allowed with <a href="static_cast.html" title="cpp/language/static cast">static_cast</a> and <a href="explicit_cast.html" title="cpp/language/explicit cast">explicit cast</a>, even if the base class does not have that member function (but the most-derived class does, when the pointer is used for access)
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">struct</span> Base <span class="br0">{</span>
<span class="br0">}</span><span class="sy4">;</span>
<span class="kw1">struct</span> Derived <span class="sy4">:</span> Base <span class="br0">{</span>
    <span class="kw4">void</span> f<span class="br0">(</span><span class="kw4">int</span> n<span class="br0">)</span> <span class="br0">{</span> <a href="../io/cout.html"><span class="kw1446">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> n <span class="sy1">&lt;&lt;</span> <span class="st0">'<span class="es1">\n</span>'</span><span class="sy4">;</span> <span class="br0">}</span>
<span class="br0">}</span><span class="sy4">;</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw4">void</span> <span class="br0">(</span>Derived<span class="sy4">::</span><span class="sy2">*</span> pd<span class="br0">)</span><span class="br0">(</span><span class="kw4">int</span><span class="br0">)</span> <span class="sy1">=</span> <span class="sy3">&amp;</span>Derived<span class="sy4">::</span><span class="me2">f</span><span class="sy4">;</span>
    <span class="kw4">void</span> <span class="br0">(</span>Base<span class="sy4">::</span><span class="sy2">*</span> pb<span class="br0">)</span><span class="br0">(</span><span class="kw4">int</span><span class="br0">)</span> <span class="sy1">=</span> <span class="kw1">static_cast</span><span class="sy1">&lt;</span><span class="kw4">void</span> <span class="br0">(</span>Base<span class="sy4">::</span><span class="sy2">*</span><span class="br0">)</span><span class="br0">(</span><span class="kw4">int</span><span class="br0">)</span><span class="sy1">&gt;</span><span class="br0">(</span>pd<span class="br0">)</span><span class="sy4">;</span>
 
    Derived d<span class="sy4">;</span>
    <span class="br0">(</span>d.<span class="sy2">*</span>pb<span class="br0">)</span><span class="br0">(</span><span class="nu0">1</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// OK, prints 1</span>
 
    Base b<span class="sy4">;</span>
    <span class="br0">(</span>b.<span class="sy2">*</span>pb<span class="br0">)</span><span class="br0">(</span><span class="nu0">2</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// Undefined behavior</span>
<span class="br0">}</span></pre></div></div>
<p>Pointers to member functions may be used as callbacks or as function objects, often after applying <span class="t-lc"><a href="../utility/functional/mem_fn.html" title="cpp/utility/functional/mem fn">std::mem_fn</a></span> or <span class="t-lc"><a href="../utility/functional/bind.html" title="cpp/utility/functional/bind">std::bind</a></span>.
</p>
<div class="t-example">
<div class="t-example-live-link"><div class="coliru-btn coliru-btn-run-init">Run this code</div></div>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="co2">#include &lt;iostream&gt;</span>
<span class="co2">#include &lt;string&gt;</span>
<span class="co2">#include &lt;algorithm&gt;</span>
<span class="co2">#include &lt;functional&gt;</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <a href="../container/vector.html"><span class="kw1064">std::<span class="me2">vector</span></span></a><span class="sy1">&lt;</span><a href="../string/basic_string.html"><span class="kw1042">std::<span class="me2">string</span></span></a><span class="sy1">&gt;</span> v <span class="sy1">=</span> <span class="br0">{</span><span class="st0">"a"</span>, <span class="st0">"ab"</span>, <span class="st0">"abc"</span><span class="br0">}</span><span class="sy4">;</span>
    <a href="../container/vector.html"><span class="kw1064">std::<span class="me2">vector</span></span></a><span class="sy1">&lt;</span><a href="../types/size_t.html"><span class="kw100">std::<span class="me2">size_t</span></span></a><span class="sy1">&gt;</span> l<span class="sy4">;</span>
    transform<span class="br0">(</span>v.<span class="me1">begin</span><span class="br0">(</span><span class="br0">)</span>, v.<span class="me1">end</span><span class="br0">(</span><span class="br0">)</span>, <a href="../iterator/back_inserter.html"><span class="kw543">std::<span class="me2">back_inserter</span></span></a><span class="br0">(</span>l<span class="br0">)</span>,
                <a href="../utility/functional/mem_fn.html"><span class="kw895">std::<span class="me2">mem_fn</span></span></a><span class="br0">(</span><span class="sy3">&amp;</span>std<span class="sy4">::</span><span class="me2">string</span><span class="sy4">::</span><span class="me2">size</span><span class="br0">)</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">for</span><span class="br0">(</span><a href="../types/size_t.html"><span class="kw100">std::<span class="me2">size_t</span></span></a> n <span class="sy4">:</span> l<span class="br0">)</span>
        <a href="../io/cout.html"><span class="kw1446">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> n <span class="sy1">&lt;&lt;</span> <span class="st0">' '</span><span class="sy4">;</span>
<span class="br0">}</span></pre></div></div>
<p>Output:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="text source-text"><pre class="de1">1 2 3</pre></div></div> 
</div>
<h3>
<span class="editsection">[<a href="http%3A//en.cppreference.com/mwiki/index.php" title="Edit section: Pointers to void">edit</a>]</span> <span class="mw-headline" id="Pointers_to_void">Pointers to void</span>
</h3>
<p>Pointer to object of any type can be <a href="implicit_cast.html" title="cpp/language/implicit cast">implicitly converted</a> to pointer to <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw4">void</span></span></span> (optionally <a href="cv.html" title="cpp/language/cv">cv-qualified</a>). The reverse conversion, which requires <a href="static_cast.html" title="cpp/language/static cast">static_cast</a> or <a href="explicit_cast.html" title="cpp/language/explicit cast">explicit cast</a>, yields the original pointer value:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw4">int</span> n <span class="sy1">=</span> <span class="nu0">1</span><span class="sy4">;</span>
<span class="kw4">int</span><span class="sy2">*</span> p <span class="sy1">=</span> <span class="sy3">&amp;</span>n<span class="sy4">;</span>
<span class="kw4">void</span><span class="sy2">*</span> pv <span class="sy1">=</span> p<span class="sy4">;</span>
 
<span class="kw4">int</span><span class="sy2">*</span> p2 <span class="sy1">=</span> <span class="kw1">static_cast</span><span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy2">*</span><span class="sy1">&gt;</span><span class="br0">(</span>pv<span class="br0">)</span><span class="sy4">;</span>
<a href="../io/cout.html"><span class="kw1446">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="sy2">*</span>p2 <span class="sy1">&lt;&lt;</span> <span class="st0">'<span class="es1">\n</span>'</span><span class="sy4">;</span> <span class="co1">// prints 1</span></pre></div></div>
<p>If the original pointer is pointing to a base class subobject within an object of some polymorphic type, <a href="dynamic_cast.html" title="cpp/language/dynamic cast">dynamic_cast</a> may be used to obtain a <code>void*</code> that is pointing at the complete object of the most derived type.
</p>
<p>Pointers to void are used to pass objects of unknown type, which is common in C interfaces: <span class="t-lc"><a href="../memory/c/malloc.html" title="cpp/memory/c/malloc">std::malloc</a></span> returns <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw4">void</span><span class="sy2">*</span></span></span>, <span class="t-lc"><a href="../algorithm/qsort.html" title="cpp/algorithm/qsort">std::qsort</a></span> expects a user-provided callback that accepts two <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw4">const</span> <span class="kw4">void</span><span class="sy2">*</span></span></span> arguments. <a rel="nofollow" class="external text" href="http%3A//pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_create.html">pthread_create</a> expects a user-provided callback that accepts and returns <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw4">void</span><span class="sy2">*</span></span></span>. In all cases, it is the caller's responsibility to cast the pointer to the correct type before use.
</p>
<h3>
<span class="editsection">[<a href="http%3A//en.cppreference.com/mwiki/index.php" title="Edit section: Null pointers">edit</a>]</span> <span class="mw-headline" id="Null_pointers">Null pointers</span>
</h3>
<p>Pointers of every type have a special value known as <i>null pointer value</i> of that type. A pointer whose value is null does not point to an object or a function (dereferencing a null pointer is undefined behavior), and compares equal to all pointers of the same type whose value is also <i>null</i>.
</p>
<p>To initialize a pointer to null or to assign the null value to an existing pointer, the null pointer literal <span class="t-c"><span class="mw-geshi cpp source-cpp">nullptr</span></span>, the null pointer constant <span class="t-lc"><a href="../types/NULL.html" title="cpp/types/NULL">NULL</a></span>, or the <a href="implicit_cast.html" title="cpp/language/implicit cast">implicit conversion</a> from the integer value <span class="t-c"><span class="mw-geshi cpp source-cpp">​<span class="nu0">0</span>​</span></span> may be used.
</p>
<p><a href="zero_initialization.html" title="cpp/language/zero initialization">Zero-</a> and <a href="value_initialization.html" title="cpp/language/value initialization">value-initialization</a> also initialize pointers to their null values.
</p>
<p>Null pointers can be used to indicate the absence of an object (e.g. <a href="../utility/functional/function/target.html" title="cpp/utility/functional/function/target"><tt>function::target()</tt></a>), or as other error condition indicators (e.g. <a href="dynamic_cast.html" title="cpp/language/dynamic cast">dynamic_cast</a>). In general, a function that receives a pointer argument almost always needs to check if the value is null and handle that case differently (for example, the <a href="delete.html" title="cpp/language/delete">delete expression</a> does nothing when a null pointer is passed)
</p>
<h3>
<span class="editsection">[<a href="http%3A//en.cppreference.com/mwiki/index.php" title="Edit section: Constness">edit</a>]</span> <span class="mw-headline" id="Constness">Constness</span>
</h3>
<ul>
<li> If <span class="t-spar">cv</span> appears before <code><b>*</b></code> in the pointer declaration, it is part of <span class="t-spar">decl-specifier-seq</span> and applies to the the pointed-to object.
</li>
<li> If <span class="t-spar">cv</span> appears after <code><b>*</b></code> in the pointer declaration, it is part of <span class="t-spar">declarator</span> and applies to the pointer that's being declared.
</li>
</ul>
<table class="wikitable">

<tr>
<th> Syntax </th>
<th> meaning
</th>
</tr>
<tr>
<td> <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw4">const</span> T <span class="sy2">*</span></span></span> </td>
<td> pointer to constant object
</td>
</tr>
<tr>
<td> <span class="t-c"><span class="mw-geshi cpp source-cpp">T <span class="kw4">const</span> <span class="sy2">*</span></span></span> </td>
<td> pointer to constant object
</td>
</tr>
<tr>
<td> <span class="t-c"><span class="mw-geshi cpp source-cpp">T <span class="sy2">*</span> <span class="kw4">const</span></span></span> </td>
<td> constant pointer to object
</td>
</tr>
<tr>
<td> <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw4">const</span> T <span class="sy2">*</span> <span class="kw4">const</span></span></span> </td>
<td> constant pointer to constant object
</td>
</tr>
</table>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="co1">// pc is a non-const pointer to const int</span>
<span class="co1">// cpc is a const pointer to const int</span>
<span class="co1">// ppc is a non-const pointer to non-const pointer to const int</span>
<span class="kw4">const</span> <span class="kw4">int</span> ci <span class="sy1">=</span> <span class="nu0">10</span>, <span class="sy2">*</span>pc <span class="sy1">=</span> <span class="sy3">&amp;</span>ci, <span class="sy2">*</span><span class="kw4">const</span> cpc <span class="sy1">=</span> pc, <span class="sy2">**</span>ppc<span class="sy4">;</span>
<span class="co1">// p is a non-const pointer to non-const int</span>
<span class="co1">// cp is a const pointer to non-const int</span>
<span class="kw4">int</span> i, <span class="sy2">*</span>p, <span class="sy2">*</span><span class="kw4">const</span> cp <span class="sy1">=</span> <span class="sy3">&amp;</span>i<span class="sy4">;</span>
 
i <span class="sy1">=</span> ci<span class="sy4">;</span>    <span class="co1">// okay, value of const int copied into non-const int</span>
<span class="sy2">*</span>cp <span class="sy1">=</span> ci<span class="sy4">;</span>  <span class="co1">// okay, non-const int pointed-to by cp can be changed</span>
pc<span class="sy2">++</span><span class="sy4">;</span>      <span class="co1">// okay, non-const pointer (to const int) can be changed</span>
pc <span class="sy1">=</span> cpc<span class="sy4">;</span>  <span class="co1">// okay, non-const pointer (to const int) can be changed</span>
pc <span class="sy1">=</span> p<span class="sy4">;</span>    <span class="co1">// okay, non-const pointer (to const int) can be changed</span>
ppc <span class="sy1">=</span> <span class="sy3">&amp;</span>pc<span class="sy4">;</span> <span class="co1">// okay, address of a pointer to const is a pointer to pointer to const</span>
 
ci <span class="sy1">=</span> <span class="nu0">1</span><span class="sy4">;</span>   <span class="co1">// error: const int cannot be changed</span>
ci<span class="sy2">++</span><span class="sy4">;</span>     <span class="co1">// error: const int cannot be changed</span>
<span class="sy2">*</span>pc <span class="sy1">=</span> <span class="nu0">2</span><span class="sy4">;</span>  <span class="co1">// error: the pointed-to const int cannot be changed</span>
cp <span class="sy1">=</span> <span class="sy3">&amp;</span>ci<span class="sy4">;</span> <span class="co1">// error: const pointer (to non-const int) cannot be changed</span>
cpc<span class="sy2">++</span><span class="sy4">;</span>    <span class="co1">// error: const pointer (to whatever) cannot be changed</span>
p <span class="sy1">=</span> pc<span class="sy4">;</span>   <span class="co1">// error: pointer to non-const cannot be pointed to a const object</span>
ppc <span class="sy1">=</span> <span class="sy3">&amp;</span>p<span class="sy4">;</span> <span class="co1">// error: pointer to pointer to const cannot be pointed</span>
          <span class="co1">//  to pointer to non-const</span></pre></div></div>
<p>In general, implicit conversion from one multi-level pointer to another follows the rules described in <a href="implicit_cast.html#Qualification_conversions" title="cpp/language/implicit cast">qualification conversions</a> and in <a href="operator_comparison.html#Pointer_comparison_operators" title="cpp/language/operator comparison">pointer comparison operators</a>.
</p>
<!-- 
NewPP limit report
Preprocessor visited node count: 2996/1000000
Preprocessor generated node count: 6884/1000000
Post‐expand include size: 66112/2097152 bytes
Template argument size: 17468/2097152 bytes
Highest expansion depth: 15/40
Expensive parser function count: 0/100
-->

<!-- Saved in parser cache with key mwiki1-mwiki_en_:pcache:idhash:5596-0!*!0!!en!*!* and timestamp 20150313154124 -->
</div>                    <!-- /bodycontent -->
                                        <!-- printfooter -->
                    <div class="printfooter">
                    Retrieved from "<a href="http%3A//en.cppreference.com/mwiki/index.php">http://en.cppreference.com/mwiki/index.php?title=cpp/language/pointer&amp;oldid=73560</a>"                    </div>
                    <!-- /printfooter -->
                                                            <!-- catlinks -->
                    <div id="catlinks" class="catlinks catlinks-allhidden"></div>                    <!-- /catlinks -->
                                                            <div class="visualClear"></div>
                    <!-- debughtml -->
                                        <!-- /debughtml -->
                </div>
                <!-- /bodyContent -->
            </div>
        </div>
        <!-- /content -->
        <!-- footer -->
        
        <!-- /footer -->
        <script>if(window.mw){
mw.loader.state({"site":"loading","user":"missing","user.groups":"ready"});
}</script>
<script src="../../../common/skin_scripts.js"></script>
<script>if(window.mw){
mw.loader.load(["mediawiki.action.view.postEdit","mediawiki.user","mediawiki.page.ready","mediawiki.searchSuggest","mediawiki.hidpi","ext.gadget.ColiruCompiler"], null, true);
}</script>
<script src="../../../common/site_scripts.js"></script>

<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-2828341-1']);
_gaq.push(['_setDomainName', 'cppreference.com']);
_gaq.push(['_trackPageview']);
</script><!-- Served in 5.285 secs. -->
	</body>
<!-- Cached 20150313154124 -->
</html>
