<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html lang="en" dir="ltr" class="client-nojs">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Lambda functions (since C++11) - cppreference.com</title>
<meta charset="UTF-8">
<meta name="generator" content="MediaWiki 1.21.2">


<link rel="shortcut icon" href="../../../favicon.ico">



<link rel="stylesheet" href="../../../common/ext.css">
<meta name="ResourceLoaderDynamicStyles" content="">
<link rel="stylesheet" href="../../../common/site_modules.css">
<style>a:lang(ar),a:lang(ckb),a:lang(fa),a:lang(kk-arab),a:lang(mzn),a:lang(ps),a:lang(ur){text-decoration:none}#toc{display:none}.editsection{display:none}
/* cache key: mwiki1-mwiki_en_:resourceloader:filter:minify-css:7:472787eddcf4605d11de8c7ef047234f */</style>

<script src="../../../common/startup_scripts.js"></script>
<script>if(window.mw){
mw.config.set({"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"cpp/language/lambda","wgTitle":"cpp/language/lambda","wgCurRevisionId":80200,"wgArticleId":5059,"wgIsArticle":true,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":["Todo with reason"],"wgBreakFrames":false,"wgPageContentLanguage":"en","wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgMonthNamesShort":["","Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"wgRelevantPageName":"cpp/language/lambda","wgRestrictionEdit":[],"wgRestrictionMove":[]});
}</script><script>if(window.mw){
mw.loader.implement("user.options",function(){mw.user.options.set({"ccmeonemails":0,"cols":80,"date":"default","diffonly":0,"disablemail":0,"disablesuggest":0,"editfont":"default","editondblclick":0,"editsection":0,"editsectiononrightclick":0,"enotifminoredits":0,"enotifrevealaddr":0,"enotifusertalkpages":1,"enotifwatchlistpages":0,"extendwatchlist":0,"externaldiff":0,"externaleditor":0,"fancysig":0,"forceeditsummary":0,"gender":"unknown","hideminor":0,"hidepatrolled":0,"imagesize":2,"justify":0,"math":1,"minordefault":0,"newpageshidepatrolled":0,"nocache":0,"noconvertlink":0,"norollbackdiff":0,"numberheadings":0,"previewonfirst":0,"previewontop":1,"quickbar":5,"rcdays":7,"rclimit":50,"rememberpassword":0,"rows":25,"searchlimit":20,"showhiddencats":0,"showjumplinks":1,"shownumberswatching":1,"showtoc":0,"showtoolbar":1,"skin":"cppreference2","stubthreshold":0,"thumbsize":2,"underline":2,"uselivepreview":0,"usenewrc":0,"watchcreations":0,"watchdefault":0,"watchdeletion":0,
"watchlistdays":3,"watchlisthideanons":0,"watchlisthidebots":0,"watchlisthideliu":0,"watchlisthideminor":0,"watchlisthideown":0,"watchlisthidepatrolled":0,"watchmoves":0,"wllimit":250,"variant":"en","language":"en","searchNs0":true,"searchNs1":false,"searchNs2":false,"searchNs3":false,"searchNs4":false,"searchNs5":false,"searchNs6":false,"searchNs7":false,"searchNs8":false,"searchNs9":false,"searchNs10":false,"searchNs11":false,"searchNs12":false,"searchNs13":false,"searchNs14":false,"searchNs15":false,"gadget-ColiruCompiler":1});;},{},{});mw.loader.implement("user.tokens",function(){mw.user.tokens.set({"editToken":"+\\","patrolToken":false,"watchToken":false});;},{},{});
/* cache key: mwiki1-mwiki_en_:resourceloader:filter:minify-js:7:ca03345b1e2c4d90a25d968753a73b92 */
}</script>
<script>if(window.mw){
mw.loader.load(["mediawiki.page.startup","mediawiki.legacy.wikibits","mediawiki.legacy.ajax"]);
}</script>
<style type="text/css">/*<![CDATA[*/
.source-cpp {line-height: normal;}
.source-cpp li, .source-cpp pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for cpp
 * CSS class: source-cpp, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie, 2007 - 2008 Benny Baumann
 * (http://qbnz.com/highlighter/ and http://geshi.org/)
 * --------------------------------------
 */
.cpp.source-cpp .de1, .cpp.source-cpp .de2 {font: normal normal 1em/1.2em monospace; margin:0; padding:0; background:none; vertical-align:top;}
.cpp.source-cpp  {font-family:monospace;}
.cpp.source-cpp .imp {font-weight: bold; color: red;}
.cpp.source-cpp li, .cpp.source-cpp .li1 {font-weight: normal; vertical-align:top;}
.cpp.source-cpp .ln {width:1px;text-align:right;margin:0;padding:0 2px;vertical-align:top;}
.cpp.source-cpp .li2 {font-weight: bold; vertical-align:top;}
.cpp.source-cpp .kw1 {color: #0000dd;}
.cpp.source-cpp .kw2 {color: #0000ff;}
.cpp.source-cpp .kw3 {color: #0000dd;}
.cpp.source-cpp .kw4 {color: #0000ff;}
.cpp.source-cpp .co1 {color: #909090;}
.cpp.source-cpp .co2 {color: #339900;}
.cpp.source-cpp .coMULTI {color: #ff0000; font-style: italic;}
.cpp.source-cpp .es0 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es1 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es2 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es3 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es4 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es5 {color: #008000; font-weight: bold;}
.cpp.source-cpp .br0 {color: #008000;}
.cpp.source-cpp .sy0 {color: #008000;}
.cpp.source-cpp .sy1 {color: #000080;}
.cpp.source-cpp .sy2 {color: #000040;}
.cpp.source-cpp .sy3 {color: #000040;}
.cpp.source-cpp .sy4 {color: #008080;}
.cpp.source-cpp .st0 {color: #008000;}
.cpp.source-cpp .nu0 {color: #000080;}
.cpp.source-cpp .nu6 {color: #000080;}
.cpp.source-cpp .nu8 {color: #000080;}
.cpp.source-cpp .nu12 {color: #000080;}
.cpp.source-cpp .nu16 {color:#000080;}
.cpp.source-cpp .nu17 {color:#000080;}
.cpp.source-cpp .nu18 {color:#000080;}
.cpp.source-cpp .nu19 {color:#000080;}
.cpp.source-cpp .ln-xtra, .cpp.source-cpp li.ln-xtra, .cpp.source-cpp div.ln-xtra {background-color: #ffc;}
.cpp.source-cpp span.xtra { display:block; }

/*]]>*/
</style>
<style type="text/css">/*<![CDATA[*/
.source-text {line-height: normal;}
.source-text li, .source-text pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for text
 * CSS class: source-text, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie, 2007 - 2008 Benny Baumann
 * (http://qbnz.com/highlighter/ and http://geshi.org/)
 * --------------------------------------
 */
.text.source-text .de1, .text.source-text .de2 {font: normal normal 1em/1.2em monospace; margin:0; padding:0; background:none; vertical-align:top;}
.text.source-text  {font-family:monospace;}
.text.source-text .imp {font-weight: bold; color: red;}
.text.source-text li, .text.source-text .li1 {font-weight: normal; vertical-align:top;}
.text.source-text .ln {width:1px;text-align:right;margin:0;padding:0 2px;vertical-align:top;}
.text.source-text .li2 {font-weight: bold; vertical-align:top;}
.text.source-text .ln-xtra, .text.source-text li.ln-xtra, .text.source-text div.ln-xtra {background-color: #ffc;}
.text.source-text span.xtra { display:block; }

/*]]>*/
</style>
<!--[if lt IE 7]><style type="text/css">body{behavior:url("/mwiki/skins/cppreference2/csshover.min.htc")}</style><![endif]-->
</head>
<body class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-cpp_language_lambda skin-cppreference2 action-view cpp-navbar">
        <!-- header -->
        
        <!-- /header -->
        <!-- content -->
        <div id="cpp-content-base">
            <div id="content">
                <a id="top"></a>
                <div id="mw-js-message" style="display:none;"></div>
                                <!-- firstHeading -->
                <h1 id="firstHeading" class="firstHeading">Lambda functions <span class="t-mark-rev t-since-cxx11">(since C++11)</span>
</h1>
                <!-- /firstHeading -->
                <!-- bodyContent -->
                <div id="bodyContent">
                                        <!-- tagline -->
                    <div id="siteSub">From cppreference.com</div>
                    <!-- /tagline -->
                                        <!-- subtitle -->
                    <div id="contentSub"><span class="subpages">&lt; <a href="../../cpp.html" title="cpp">cpp</a>‎ | <a href="../language.1.html" title="cpp/language">language</a></span></div>
                    <!-- /subtitle -->
                                                            <!-- bodycontent -->
                    <div id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr">
<div class="t-navbar" style="">
<div class="t-navbar-sep"> </div>
<div class="t-navbar-head">
<a href="../../cpp.html" title="cpp"> C++</a><div class="t-navbar-menu"><div>
<div><table class="t-nv-begin" cellpadding="0" style="line-height:1.1em;">
<tr class="t-nv"><td colspan="5"> <a href="../language.1.html" title="cpp/language"> Language</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../header.html" title="cpp/header"> Standard library headers</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../concept.html" title="cpp/concept"> Concepts</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../utility.html" title="cpp/utility"> Utilities library</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../string.html" title="cpp/string"> Strings library</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../container.html" title="cpp/container"> Containers library</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../algorithm.html" title="cpp/algorithm"> Algorithms library</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../iterator.html" title="cpp/iterator"> Iterators library</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../numeric.html" title="cpp/numeric"> Numerics library</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../io.html" title="cpp/io"> Input/output library</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../locale.html" title="cpp/locale"> Localizations library</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../regex.html" title="cpp/regex"> Regular expressions library</a> <span class="t-mark-rev t-since-cxx11">(C++11)</span> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../atomic.html" title="cpp/atomic"> Atomic operations library</a> <span class="t-mark-rev t-since-cxx11">(C++11)</span> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../thread.html" title="cpp/thread"> Thread support library</a> <span class="t-mark-rev t-since-cxx11">(C++11)</span> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../experimental.html" title="cpp/experimental"> Technical Specifications</a> </td></tr>
</table></div>
<div></div>
</div></div>
</div>
<div class="t-navbar-sep"> </div>
<div class="t-navbar-head"><a href="../language.1.html" title="cpp/language"> C++ language</a></div>
<div class="t-navbar-sep"> </div>
<div class="t-navbar-head">
<a href="functions.html" title="cpp/language/functions"> Functions</a><div class="t-navbar-menu"><div>
<div style="display:inline-block">
<div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv-h2"><td colspan="5"> Declarations </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="function.html" title="cpp/language/function"> function declaration</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="function.html#Parameter_list" title="cpp/language/function"> function parameter list</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="function.html#Function_definition" title="cpp/language/function"> function definition</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="default_arguments.html" title="cpp/language/default arguments"> default arguments</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="variadic_arguments.html" title="cpp/language/variadic arguments"> variadic arguments</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="inline.html" title="cpp/language/inline"> inline specifier</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <strong class="selflink"> lambda expression</strong> <span class="t-mark-rev t-since-cxx11">(C++11)</span>
</td></tr>
<tr class="t-nv-h2"><td colspan="5"> Function calls </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="adl.html" title="cpp/language/adl"> argument-dependent lookup (ADL)</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="operator_other.html#Built-in_function_call_operator" title="cpp/language/operator other"> function-call operator</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../concept/FunctionObject.html" title="cpp/concept/FunctionObject"> function objects</a> </td></tr>
<tr class="t-nv-h2"><td colspan="5"> Overloading </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="overload_resolution.html" title="cpp/language/overload resolution"> overload resolution</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="operators.html" title="cpp/language/operators"> operator overloading</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="overloaded_address.html" title="cpp/language/overloaded address"> address of an overload set</a> </td></tr>
</table></div>
</div>
<div></div>
</div></div>
</div>
<div class="t-navbar-sep"> </div>
</div>
<p>Constructs a <a href="http%3A//en.wikipedia.com/wiki/Closure_%28computer_science%29" class="extiw" title="enwiki:Closure (computer science)">closure</a>: an unnamed function object capable of capturing variables in scope.
</p>
<table id="toc" class="toc"><tr><td>
<div id="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="lambda.html#Syntax"><span class="tocnumber">1</span> <span class="toctext">Syntax</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="lambda.html#Explanation"><span class="tocnumber">2</span> <span class="toctext">Explanation</span></a></li>
<li class="toclevel-1">
<a href="lambda.html#ClosureType%3A%3Aoperator.28.29.28params.29"><span class="tocnumber">3</span> <span class="toctext"><span>ClosureType::</span>operator()(<span>params</span>)</span></a>
<ul>
<li class="toclevel-2"><a href="lambda.html#Dangling_references"><span class="tocnumber">3.1</span> <span class="toctext">Dangling references</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="lambda.html#ClosureType%3A%3Aoperator_ret.28.2A.29.28params.29.28.29"><span class="tocnumber">4</span> <span class="toctext"><span>ClosureType::</span>operator ret(*)(<span>params</span>)()</span></a></li>
<li class="toclevel-1"><a href="lambda.html#ClosureType%3A%3AClosureType.28.29"><span class="tocnumber">5</span> <span class="toctext"><span>ClosureType::</span>ClosureType()</span></a></li>
<li class="toclevel-1"><a href="lambda.html#ClosureType%3A%3Aoperator.3D.28const_ClosureType.26.29"><span class="tocnumber">6</span> <span class="toctext"><span>ClosureType::</span>operator=(const ClosureType&amp;)</span></a></li>
<li class="toclevel-1"><a href="lambda.html#ClosureType%3A%3A.7EClosureType.28.29"><span class="tocnumber">7</span> <span class="toctext"><span>ClosureType::</span>~ClosureType()</span></a></li>
<li class="toclevel-1">
<a href="lambda.html#ClosureType%3A%3ACaptures"><span class="tocnumber">8</span> <span class="toctext"><span>ClosureType::</span><span>Captures</span></span></a>
<ul>
<li class="toclevel-2 tocsection-4"><a href="lambda.html#Lambda_capture"><span class="tocnumber">8.1</span> <span class="toctext">Lambda capture</span></a></li>
<li class="toclevel-2 tocsection-5"><a href="lambda.html#Example"><span class="tocnumber">8.2</span> <span class="toctext">Example</span></a></li>
<li class="toclevel-2 tocsection-6"><a href="lambda.html#See_also"><span class="tocnumber">8.3</span> <span class="toctext">See also</span></a></li>
</ul>
</li>
</ul>
</td></tr></table>
<h3>
<span class="editsection">[<a href="http%3A//en.cppreference.com/mwiki/index.php" title="Edit section: Syntax">edit</a>]</span> <span class="mw-headline" id="Syntax">Syntax</span>
</h3>
<table class="t-sdsc-begin">

<tr>
<td colspan="10" class="t-sdsc-sep">
</td>
</tr>
<tr class="t-sdsc">
<td> <code><b>[</b></code> <span class="t-spar">capture-list</span> <code><b>]</b></code> <code><b>(</b></code> <span class="t-spar">params</span> <code><b>)</b></code> <code><b>mutable</b></code><span class="t-mark">(optional)</span> <span class="t-spar">exception</span> <span class="t-spar">attribute</span> <code><b>-&gt;</b></code> <span class="t-spar">ret</span> <code><b>{</b></code> <span class="t-spar">body</span> <code><b>}</b></code>
</td>
<td> (1)
</td>
<td class="t-sdsc-nopad">
</td>
</tr>



<tr>
<td colspan="10" class="t-sdsc-sep">
</td>
</tr>
<tr class="t-sdsc">
<td> <code><b>[</b></code> <span class="t-spar">capture-list</span> <code><b>]</b></code> <code><b>(</b></code> <span class="t-spar">params</span> <code><b>)</b></code> <code><b>-&gt;</b></code> <span class="t-spar">ret</span> <code><b>{</b></code> <span class="t-spar">body</span> <code><b>}</b></code>
</td>
<td> (2)
</td>
<td class="t-sdsc-nopad">
</td>
</tr>



<tr>
<td colspan="10" class="t-sdsc-sep">
</td>
</tr>
<tr class="t-sdsc">
<td> <code><b>[</b></code> <span class="t-spar">capture-list</span> <code><b>]</b></code> <code><b>(</b></code> <span class="t-spar">params</span> <code><b>)</b></code> <code><b>{</b></code> <span class="t-spar">body</span> <code><b>}</b></code>
</td>
<td> (3)
</td>
<td class="t-sdsc-nopad">
</td>
</tr>



<tr>
<td colspan="10" class="t-sdsc-sep">
</td>
</tr>
<tr class="t-sdsc">
<td> <code><b>[</b></code> <span class="t-spar">capture-list</span> <code><b>]</b></code> <code><b>{</b></code> <span class="t-spar">body</span> <code><b>}</b></code>
</td>
<td> (4)
</td>
<td class="t-sdsc-nopad">
</td>
</tr>



<tr>
<td colspan="10" class="t-sdsc-sep">
</td>
</tr>
</table>
<p>1) Full declaration
</p>
<p>2) Declaration of a const lambda: the objects captured by copy cannot be modified.
</p>
<p>3) Omitted trailing-return-type: the return type of the closure's <code>operator()</code> is determined according to the following rules:
</p>
 <table class="t-rev-begin">
<tr class="t-rev t-until-cxx14">
<td>
<ul><li> if the <span class="t-spar">body</span> consists of nothing but a single <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw1">return</span></span></span> statement with an expression, the return type is the type of the returned expression (after <a href="implicit_cast.html#Lvalue_transformations" title="cpp/language/implicit cast">lvalue-to-rvalue, array-to-pointer, or function-to-pointer implicit conversion</a>)
</li></ul>
<ul><li> otherwise, the return type is <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw4">void</span></span></span>
</li></ul>
</td>
<td><span class="t-mark-rev t-until-cxx14">(until C++14)</span></td>
</tr>
<tr class="t-rev t-since-cxx14">
<td>
<p>The return type is <a href="template_argument_deduction.html" title="cpp/language/template argument deduction">deduced</a> from <a href="return.html" title="cpp/language/return"><tt>return</tt></a> statements as if for a function whose <a href="function.html#Return_type_deduction" title="cpp/language/function">return type is declared auto</a>.
</p>
</td>
<td><span class="t-mark-rev t-since-cxx14">(since C++14)</span></td>
</tr>
</table>
<p>4) Omitted parameter list: function takes no arguments, as if the parameter list was <code><b>()</b></code>
</p>
<h3>
<span class="editsection">[<a href="http%3A//en.cppreference.com/mwiki/index.php" title="Edit section: Explanation">edit</a>]</span> <span class="mw-headline" id="Explanation">Explanation</span>
</h3>
<table class="t-par-begin">


<tr class="t-par">
<td>  mutable
</td>
<td> -
</td>
<td>  allows <span class="t-spar">body</span> to modify the parameters captured by copy, and to call their non-const member functions
</td>
</tr>
<tr class="t-par">
<td>  <span class="t-spar">exception</span>
</td>
<td> -
</td>
<td>  provides the <a href="except_spec.html" title="cpp/language/except spec">exception specification</a> or the <a href="noexcept_spec.html" title="cpp/language/noexcept spec">noexcept clause</a> for operator() of the closure type
</td>
</tr>
<tr class="t-par">
<td>  <span class="t-spar">attribute</span>
</td>
<td> -
</td>
<td>  provides the <a href="attributes.html" title="cpp/language/attributes">attribute specification</a> for operator() of the closure type
</td>
</tr>
<tr class="t-par">
<td>  <span class="t-spar">capture-list</span>
</td>
<td> -
</td>
<td>  a comma-separated list of zero or more <a href="lambda.html#Lambda_capture">captures</a>, optionally beginning with a <span class="t-spar">capture-default</span>.
<p>Capture list can be passed as follows (see below for the detailed description): 
</p>
<ul>
<li>
<code><b>[a,&amp;b]</b></code> where <i>a</i> is captured by value and <i>b</i> is captured by reference.
</li>
<li>
<code><b>[this]</b></code> captures the <a href="this.html" title="cpp/language/this"><code><b>this</b></code> pointer</a> by value
</li>
<li>
<code><b>[&amp;]</b></code> captures all <a href="storage_duration.html" title="cpp/language/storage duration">automatic</a> variables <a href="definition.html#ODR-use" title="cpp/language/definition">odr-used</a> in the body of the lambda by reference
</li>
<li>
<code><b>[=]</b></code> captures all <a href="storage_duration.html" title="cpp/language/storage duration">automatic</a> variables <a href="definition.html#ODR-use" title="cpp/language/definition">odr-used</a> in the body of the lambda by value
</li>
<li>
<code><b>[]</b></code> captures nothing 
</li>
</ul>
</td>
</tr>
<tr class="t-par">
<td>  <span class="t-spar">params</span>
</td>
<td> -
</td>
<td>  The list of parameters, as in <a href="function.html" title="cpp/language/function">named functions</a><span class="t-rev-inl t-until-cxx14"><span>, except that <a href="default_arguments.html" title="cpp/language/default arguments">default arguments</a> are not allowed</span> <span><span class="t-mark-rev t-until-cxx14">(until C++14)</span></span></span>. <span class="t-rev-inl t-since-cxx14"><span>if <code>auto</code> is used as a type of a parameter, the lambda is a <i>generic lambda</i></span> <span><span class="t-mark-rev t-since-cxx14">(since C++14)</span></span></span>
</td>
</tr>
<tr class="t-par">
<td>  <span class="t-spar">ret</span>
</td>
<td> -
</td>
<td>  Return type. If not present it's implied by the function return statements ( or void if it doesn't return any value)
</td>
</tr>
<tr class="t-par">
<td>  <span class="t-spar">body</span>
</td>
<td> -
</td>
<td>  Function body
</td>
</tr>
</table>
<p>The lambda expression constructs an unnamed prvalue temporary object of unique unnamed non-union non-aggregate type, known as <i>closure type</i>, which is declared (for the purposes of <a href="adl.html" title="cpp/language/adl">ADL</a>) in the smallest block scope, class scope, or namespace scope that contains the lambda expression. The closure type has the following members:
</p>
<div class="t-member">
<h2> <span class="mw-headline" id="ClosureType::operator.28.29.28params.29"> <span style="font-size:0.7em; line-height:130%">ClosureType::</span>operator()(<span class="t-spar">params</span>) </span>
</h2>
<table class="t-dcl-begin"><tbody>
<tr class="t-dcl">
<td> <div><span class="mw-geshi cpp source-cpp">ret operator<span class="br0">(</span><span class="br0">)</span><span class="br0">(</span>params<span class="br0">)</span> <span class="kw4">const</span> <span class="br0">{</span> body <span class="br0">}</span></span></div>
</td>
<td class="t-dcl-nopad">  </td>
<td> <span class="t-mark">(the keyword mutable was not used)</span> </td>
</tr>
<tr class="t-dcl">
<td> <div><span class="mw-geshi cpp source-cpp">ret operator<span class="br0">(</span><span class="br0">)</span><span class="br0">(</span>params<span class="br0">)</span> <span class="br0">{</span> body <span class="br0">}</span></span></div>
</td>
<td class="t-dcl-nopad">  </td>
<td> <span class="t-mark">(the keyword mutable was used)</span> </td>
</tr>
<tr class="t-dcl t-since-cxx14">
<td> <div><span class="mw-geshi cpp source-cpp"><span class="kw1">template</span><span class="sy1">&lt;</span>template<span class="sy2">-</span>params<span class="sy1">&gt;</span><br>
ret operator<span class="br0">(</span><span class="br0">)</span><span class="br0">(</span>params<span class="br0">)</span> <span class="br0">{</span> body <span class="br0">}</span></span></div>
</td>
<td class="t-dcl-nopad">  </td>
<td> <span class="t-mark-rev t-since-cxx14">(since C++14)</span> <br><span class="t-mark">(generic lambda)</span> </td>
</tr>
<tr class="t-dcl-sep">
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>Executes the body of the lambda-expression, when invoked. When accessing a variable, accesses its captured copy (for the entities captured by copy), or the original object (for the entities captured by reference). Unless the keyword <span class="t-c"><span class="mw-geshi cpp source-cpp">mutable</span></span> was used in the lambda-expression, the function-call operator is const-qualified and the objects that were captured by copy are non-modifiable from inside this <span class="t-c"><span class="mw-geshi cpp source-cpp">operator<span class="br0">(</span><span class="br0">)</span></span></span>. The function-call operator is never volatile-qualified and never virtual.
</p>
 <table class="t-rev-begin">
<tr class="t-rev t-since-cxx14">
<td>
<p>For every parameter in <span class="t-spar">params</span> whose type is specified as <code>auto</code>, an invented template parameter is added to <span class="t-spar">template-params</span>, in order of appearance. The invented template parameter may be a <a href="parameter_pack.html" title="cpp/language/parameter pack">parameter pack</a> if the corresponding function member of <span class="t-spar">params</span> is a function parameter pack.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="co1">// generic lambda, operator() is a template with two parameters</span>
<span class="kw4">auto</span> glambda <span class="sy1">=</span> <span class="br0">[</span><span class="br0">]</span><span class="br0">(</span><span class="kw4">auto</span> a, <span class="kw4">auto</span><span class="sy3">&amp;&amp;</span> b<span class="br0">)</span> <span class="br0">{</span> <span class="kw1">return</span> a <span class="sy1">&lt;</span> b<span class="sy4">;</span> <span class="br0">}</span><span class="sy4">;</span>
<span class="kw4">bool</span> b <span class="sy1">=</span> glambda<span class="br0">(</span><span class="nu0">3</span>, <span class="nu16">3.14</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// OK</span>
<span class="co1">// generic lambda, operator() is a template with one parameter</span>
<span class="kw4">auto</span> vglambda <span class="sy1">=</span> <span class="br0">[</span><span class="br0">]</span><span class="br0">(</span><span class="kw4">auto</span> printer<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw1">return</span> <span class="br0">[</span><span class="sy1">=</span><span class="br0">]</span><span class="br0">(</span><span class="kw4">auto</span><span class="sy3">&amp;&amp;</span>... <span class="me1">ts</span><span class="br0">)</span> <span class="br0">{</span> <span class="co1">// generic lambda, ts is a parameter pack</span>
        printer<span class="br0">(</span><a href="../utility/forward.html"><span class="kw920">std::<span class="me2">forward</span></span></a><span class="sy1">&lt;</span>decltype<span class="br0">(</span>ts<span class="br0">)</span><span class="sy1">&gt;</span><span class="br0">(</span>ts<span class="br0">)</span>...<span class="br0">)</span><span class="sy4">;</span>
        <span class="kw1">return</span> <span class="br0">[</span><span class="sy1">=</span><span class="br0">]</span><span class="br0">{</span> printer<span class="br0">(</span>ts...<span class="br0">)</span><span class="sy4">;</span> <span class="br0">}</span><span class="sy4">;</span> <span class="co1">// nullary lambda (takes no parameters)</span>
    <span class="br0">}</span><span class="sy4">;</span>
<span class="br0">}</span><span class="sy4">;</span>
<span class="kw4">auto</span> p <span class="sy1">=</span> vglambda<span class="br0">(</span> <span class="br0">[</span><span class="br0">]</span><span class="br0">(</span><span class="kw4">auto</span> v1, <span class="kw4">auto</span> v2, <span class="kw4">auto</span> v3<span class="br0">)</span> <span class="br0">{</span>
                          <a href="../io/cout.html"><span class="kw1453">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> v1 <span class="sy1">&lt;&lt;</span> v2 <span class="sy1">&lt;&lt;</span> v3<span class="sy4">;</span>
                      <span class="br0">}</span> <span class="br0">)</span><span class="sy4">;</span>
<span class="kw4">auto</span> q <span class="sy1">=</span> p<span class="br0">(</span><span class="nu0">1</span>, <span class="st0">'a'</span>, <span class="nu16">3.14</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// outputs 1a3.14</span>
q<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>                      <span class="co1">// outputs 1a3.14</span></pre></div></div>
<p><code>ClosureType</code>'s <code>operator()</code> cannot be explicitly instantiated or explicitly specialized.
</p>
</td>
<td><span class="t-mark-rev t-since-cxx14">(since C++14)</span></td>
</tr>
</table>
<p>the exception specification <span class="t-spar">exception</span> on the lambda-expression applies to the function-call operator or operator template.
</p>
<p>For the purpose of <a href="lookup.html" title="cpp/language/lookup">name lookup</a>, determining the type and value of the <a href="this.html" title="cpp/language/this">this pointer</a> and for accessing non-static class members, the body of the closure type's function call operator is considered in the context of the lambda-expression.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">struct</span> X <span class="br0">{</span>
   <span class="kw4">int</span> x, y<span class="sy4">;</span>
   <span class="kw4">int</span> operator<span class="br0">(</span><span class="br0">)</span><span class="br0">(</span><span class="kw4">int</span><span class="br0">)</span><span class="sy4">;</span>
   <span class="kw4">void</span> f<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
     <span class="co1">// the context of the following lambda is the member function X::f</span>
     <span class="br0">[</span><span class="sy1">=</span><span class="br0">]</span><span class="br0">(</span><span class="br0">)</span><span class="sy2">-</span><span class="sy1">&gt;</span><span class="kw4">int</span> <span class="br0">{</span>
         <span class="kw1">return</span> operator<span class="br0">(</span><span class="br0">)</span><span class="br0">(</span>this<span class="sy2">-</span><span class="sy1">&gt;</span>x <span class="sy2">+</span> y<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// X::operator()(this-&gt;x + (*this).y)</span>
                                         <span class="co1">// this has type X*</span>
         <span class="br0">}</span><span class="sy4">;</span>
    <span class="br0">}</span>
<span class="br0">}</span><span class="sy4">;</span></pre></div></div>
<p><code>ClosureType</code>'s <code>operator()</code> cannot be named in a <a href="friend.html" title="cpp/language/friend">friend</a> declaration.
</p>
<h3> <span class="mw-headline" id="Dangling_references">Dangling references</span>
</h3>
<p>If an entity is captured by reference, implicitly or explicitly, and the function call operator of the closure object is invoked after the entity's lifetime has ended, undefined behavior occurs. The C++ closures do not extend the lifetimes of the captured references.
</p>
<p>Same applies to the lifetime of the object pointed to by the captured <code>this</code> pointer.
</p>
</div>
<div class="t-member">
<h2> <span class="mw-headline" id="ClosureType::operator_ret.28.2A.29.28params.29.28.29"> <span style="font-size:0.7em; line-height:130%">ClosureType::</span>operator ret(*)(<span class="t-spar">params</span>)() </span>
</h2>
<table class="t-dcl-begin"><tbody>
<tr class="t-dcl">
<td> <div><span class="mw-geshi cpp source-cpp"><span class="kw1">typedef</span> ret<span class="br0">(</span><span class="sy2">*</span>F<span class="br0">)</span><span class="br0">(</span>params<span class="br0">)</span><span class="sy4">;</span><br>
operator F<span class="br0">(</span><span class="br0">)</span> <span class="kw4">const</span><span class="sy4">;</span></span></div>
</td>
<td class="t-dcl-nopad">  </td>
<td> <span class="t-mark">(capture-less non-generic lambda)</span> </td>
</tr>
<tr class="t-dcl t-since-cxx14">
<td> <div><span class="mw-geshi cpp source-cpp"><span class="kw1">template</span><span class="sy1">&lt;</span>template<span class="sy2">-</span>params<span class="sy1">&gt;</span> <span class="kw1">using</span> fptr_t <span class="sy1">=</span> <span class="coMULTI">/*see below*/</span><span class="sy4">;</span><br>
<p><span class="kw1">template</span><span class="sy1">&lt;</span>template<span class="sy2">-</span>params<span class="sy1">&gt;</span><br>
</p>
operator fptr_t<span class="sy1">&lt;</span>template<span class="sy2">-</span>params<span class="sy1">&gt;</span><span class="br0">(</span><span class="br0">)</span> <span class="kw4">const</span><span class="sy4">;</span></span></div>
</td>
<td class="t-dcl-nopad">  </td>
<td> <span class="t-mark-rev t-since-cxx14">(since C++14)</span> <br><span class="t-mark">(capture-less generic lambda)</span> </td>
</tr>
<tr class="t-dcl-sep">
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>This <a href="cast_operator.html" title="cpp/language/cast operator">user-defined conversion function</a> is only defined if the capture list of the lambda-expression is empty. 
</p>
 <table class="t-rev-begin">
<tr class="t-rev t-since-cxx14">
<td>
<p>A generic captureless lambda has user-defined conversion function template with the same invented template parameter list as the function-call operator template. If the return type is empty or auto, it is obtained by return type deduction on the function template specialization, which, in turn, is obtained by <a href="template_argument_deduction.html" title="cpp/language/template argument deduction">template argument deduction</a> for conversion function templates.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw4">void</span> f1<span class="br0">(</span><span class="kw4">int</span> <span class="br0">(</span><span class="sy2">*</span><span class="br0">)</span><span class="br0">(</span><span class="kw4">int</span><span class="br0">)</span><span class="br0">)</span> <span class="br0">{</span> <span class="br0">}</span>
<span class="kw4">void</span> f2<span class="br0">(</span><span class="kw4">char</span> <span class="br0">(</span><span class="sy2">*</span><span class="br0">)</span><span class="br0">(</span><span class="kw4">int</span><span class="br0">)</span><span class="br0">)</span> <span class="br0">{</span> <span class="br0">}</span>
<span class="kw4">void</span> h<span class="br0">(</span><span class="kw4">int</span> <span class="br0">(</span><span class="sy2">*</span><span class="br0">)</span><span class="br0">(</span><span class="kw4">int</span><span class="br0">)</span><span class="br0">)</span> <span class="br0">{</span> <span class="br0">}</span> <span class="co1">// #1</span>
<span class="kw4">void</span> h<span class="br0">(</span><span class="kw4">char</span> <span class="br0">(</span><span class="sy2">*</span><span class="br0">)</span><span class="br0">(</span><span class="kw4">int</span><span class="br0">)</span><span class="br0">)</span> <span class="br0">{</span> <span class="br0">}</span> <span class="co1">// #2</span>
<span class="kw4">auto</span> glambda <span class="sy1">=</span> <span class="br0">[</span><span class="br0">]</span><span class="br0">(</span><span class="kw4">auto</span> a<span class="br0">)</span> <span class="br0">{</span> <span class="kw1">return</span> a<span class="sy4">;</span> <span class="br0">}</span><span class="sy4">;</span>
f1<span class="br0">(</span>glambda<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// OK</span>
f2<span class="br0">(</span>glambda<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// error: not convertible</span>
h<span class="br0">(</span>glambda<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// OK: calls #1 since #2 is not convertible</span>
 
<span class="kw4">int</span><span class="sy3">&amp;</span> <span class="br0">(</span><span class="sy2">*</span>fpi<span class="br0">)</span><span class="br0">(</span><span class="kw4">int</span><span class="sy2">*</span><span class="br0">)</span> <span class="sy1">=</span> <span class="br0">[</span><span class="br0">]</span><span class="br0">(</span><span class="kw4">auto</span><span class="sy2">*</span> a<span class="br0">)</span> <span class="sy2">-</span><span class="sy1">&gt;</span> <span class="kw4">auto</span><span class="sy3">&amp;</span> <span class="br0">{</span> <span class="kw1">return</span> <span class="sy2">*</span>a<span class="sy4">;</span> <span class="br0">}</span><span class="sy4">;</span> <span class="co1">// OK</span></pre></div></div>
</td>
<td><span class="t-mark-rev t-since-cxx14">(since C++14)</span></td>
</tr>
</table>
<p>The value returned by this conversion function is a pointer to a function with C++ <a href="language_linkage.html" title="cpp/language/language linkage">language linkage</a> that, when invoked, has the same effect as invoking the closure object's function call operator directly.
</p>
</div>
<div class="t-member">
<h2> <span class="mw-headline" id="ClosureType::ClosureType.28.29"> <span style="font-size:0.7em; line-height:130%">ClosureType::</span>ClosureType() </span>
</h2>
<table class="t-dcl-begin"><tbody>
<tr class="t-dcl">
<td> <div><span class="mw-geshi cpp source-cpp">ClosureType<span class="br0">(</span><span class="br0">)</span> <span class="sy1">=</span> delete<span class="sy4">;</span></span></div>
</td>
<td class="t-dcl-nopad">  </td>
<td> <span class="t-mark-rev t-until-cxx17">(until C++17)</span> </td>
</tr>
<tr class="t-dcl">
<td> <div><span class="mw-geshi cpp source-cpp">ClosureType<span class="br0">(</span><span class="kw4">const</span> ClosureType<span class="sy3">&amp;</span> <span class="br0">)</span> <span class="sy1">=</span> <span class="kw1">default</span><span class="sy4">;</span></span></div>
</td>
<td class="t-dcl-nopad">  </td>
<td> <span class="t-mark-rev t-since-cxx17">(since C++17)</span> </td>
</tr>
<tr class="t-dcl">
<td> <div><span class="mw-geshi cpp source-cpp">ClosureType<span class="br0">(</span>ClosureType<span class="sy3">&amp;&amp;</span> <span class="br0">)</span> <span class="sy1">=</span> <span class="kw1">default</span><span class="sy4">;</span></span></div>
</td>
<td class="t-dcl-nopad">  </td>
<td> <span class="t-mark-rev t-since-cxx17">(since C++17)</span> </td>
</tr>
<tr class="t-dcl-sep">
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>Closure types are not <a href="../concept/DefaultConstructible.html" title="cpp/concept/DefaultConstructible"><code>DefaultConstructible</code></a>. Closure types have <span class="t-rev-inl t-until-cxx17"><span>a deleted</span> <span><span class="t-mark-rev t-until-cxx17">(until C++17)</span></span></span><span class="t-rev-inl t-since-cxx17"><span>no</span> <span><span class="t-mark-rev t-since-cxx17">(since C++17)</span></span></span> default constructor. The copy constructor and the move constructor are <span class="t-rev-inl t-until-cxx17"><span>implicitly-declared</span> <span><span class="t-mark-rev t-until-cxx17">(until C++17)</span></span></span><span class="t-rev-inl t-since-cxx17"><span>declared as defaulted</span> <span><span class="t-mark-rev t-since-cxx17">(since C++17)</span></span></span> and may be implicitly-defined according to the usual rules for <a href="copy_constructor.html" title="cpp/language/copy constructor">copy constructors</a> and <a href="move_constructor.html" title="cpp/language/move constructor">move constructors</a>.
</p>
</div>
<div class="t-member">
<h2> <span class="mw-headline" id="ClosureType::operator.3D.28const_ClosureType.26.29"> <span style="font-size:0.7em; line-height:130%">ClosureType::</span>operator=(const ClosureType&amp;) </span>
</h2>
<table class="t-dcl-begin"><tbody>

<tr class="t-dcl">
<td class="t-dcl-nopad"> <div><span class="mw-geshi cpp source-cpp">ClosureType<span class="sy3">&amp;</span> operator<span class="sy1">=</span><span class="br0">(</span><span class="kw4">const</span> ClosureType<span class="sy3">&amp;</span><span class="br0">)</span> <span class="sy1">=</span> delete<span class="sy4">;</span></span></div>
</td>
<td class="t-dcl-nopad">  </td>
<td class="t-dcl-nopad">  </td>
</tr>
<tr class="t-dcl-sep">
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>Closure types are not <a href="../concept/CopyAssignable.html" title="cpp/concept/CopyAssignable"><code>CopyAssignable</code></a>.
</p>
</div>
<div class="t-member">
<h2> <span class="mw-headline" id="ClosureType::.7EClosureType.28.29"> <span style="font-size:0.7em; line-height:130%">ClosureType::</span>~ClosureType() </span>
</h2>
<table class="t-dcl-begin"><tbody>

<tr class="t-dcl">
<td class="t-dcl-nopad"> <div><span class="mw-geshi cpp source-cpp">~ClosureType<span class="br0">(</span><span class="br0">)</span> <span class="sy1">=</span> <span class="kw1">default</span><span class="sy4">;</span></span></div>
</td>
<td class="t-dcl-nopad">  </td>
<td class="t-dcl-nopad">  </td>
</tr>
<tr class="t-dcl-sep">
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>The destructor is implicitly-declared.
</p>
</div>
<div class="t-member">
<h2> <span class="mw-headline" id="ClosureType::Captures"> <span style="font-size:0.7em; line-height:130%">ClosureType::</span><span class="t-spar">Captures</span> </span>
</h2>
<table class="t-dcl-begin"><tbody>

<tr class="t-dcl">
<td class="t-dcl-nopad"> <div><span class="mw-geshi cpp source-cpp">T1 a<span class="sy4">;</span><br>
<p>T2 b<span class="sy4">;</span><br>
</p>
...</span></div>
</td>
<td class="t-dcl-nopad">  </td>
<td class="t-dcl-nopad">  </td>
</tr>
<tr class="t-dcl-sep">
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>If the lambda-expression captures anything by copy (either implicitly with capture clause <code><b>[=]</b></code> or explicitly with a capture that does not include the character &amp;, e.g. <code><b>[a, b, c]</b></code>), the closure type includes unnamed non-static data members, declared in unspecified order, that hold copies of all entities that were so captured.
</p>
<p>Those data members that correspond to captures without initializers are <a href="direct_initialization.html" title="cpp/language/direct initialization">direct-initialized</a> when the lambda-expression is evaluated. Those that correspond to captures with initializers are initialized as the initializer requires (could be copy- or direct-initialization). If an array is captured, array elements are direct-initialized in increasing index order. The order in which the data members are initialized is the order in which they are declared (which is unspecified).
</p>
<p>The type of each data member is the type of the corresponding captured entity, except if the entity has reference type (in that case, references to functions are captured as-is, and references to objects are captured as copies of the referenced objects).
</p>
<p>For the entities that are captured by reference (with the default capture <code><b>[&amp;]</b></code> or when using the character &amp;, e.g. <code><b>[&amp;a, &amp;b, &amp;c]</b></code>), it is unspecified if additional data members are declared in the closure type.
</p>
</div>
<p>Lambda-expressions are not allowed in <a href="expressions.html#Unevaluated_expressions" title="cpp/language/expressions">unevaluated expressions</a>, <a href="template_parameters.html" title="cpp/language/template parameters">template arguments</a>, <a href="type_alias.html" title="cpp/language/type alias">alias declarations</a>, <a href="typedef.html" title="cpp/language/typedef">typedef declarations</a>, and anywhere in a function (or function template) declaration except the function body and the function's <a href="default_arguments.html" title="cpp/language/default arguments">default arguments</a>.
</p>
<h3>
<span class="editsection">[<a href="http%3A//en.cppreference.com/mwiki/index.php" title="Edit section: Lambda capture">edit</a>]</span> <span class="mw-headline" id="Lambda_capture">Lambda capture</span>
</h3>
<p>The <span class="t-spar">capture-list</span> is a comma-separated list of zero or more <i>captures</i>, optionally beginning with the <span class="t-spar">capture-default</span>. The only capture defaults are <code><b>&amp;</b></code> (implicitly catch the <a href="definition.html#ODR-use" title="cpp/language/definition">odr-used</a> automatic variables and <code>this</code> by reference) and <code><b> = </b></code> (implicitly catch the odr-used automatic variables and <code>this</code> by value).
</p>
<p>The syntax of an individual capture in <span class="t-spar">capture-list</span> is
</p>
<table class="t-sdsc-begin">

<tr>
<td colspan="10" class="t-sdsc-sep">
</td>
</tr>
<tr class="t-sdsc">
<td> <span class="t-spar">identifier</span>
</td>
<td> (1)
</td>
<td class="t-sdsc-nopad">
</td>
</tr>



<tr>
<td colspan="10" class="t-sdsc-sep">
</td>
</tr>
<tr class="t-sdsc">
<td> <span class="t-spar">identifier</span> <code><b>...</b></code>
</td>
<td> (2)
</td>
<td class="t-sdsc-nopad">
</td>
</tr>



<tr>
<td colspan="10" class="t-sdsc-sep">
</td>
</tr>
<tr class="t-sdsc">
<td> <span class="t-spar">identifier</span> <span class="t-spar">initializer</span>
</td>
<td> (3)
</td>
<td> <span class="t-mark-rev t-since-cxx14">(C++14)</span>
</td>
</tr>



<tr>
<td colspan="10" class="t-sdsc-sep">
</td>
</tr>
<tr class="t-sdsc">
<td> <code><b>&amp;</b></code> <span class="t-spar">identifier</span>
</td>
<td> (4)
</td>
<td class="t-sdsc-nopad">
</td>
</tr>



<tr>
<td colspan="10" class="t-sdsc-sep">
</td>
</tr>
<tr class="t-sdsc">
<td> <code><b>&amp;</b></code> <span class="t-spar">identifier</span> <code><b>...</b></code>
</td>
<td> (5)
</td>
<td class="t-sdsc-nopad">
</td>
</tr>



<tr>
<td colspan="10" class="t-sdsc-sep">
</td>
</tr>
<tr class="t-sdsc">
<td> <code><b>&amp;</b></code> <span class="t-spar">identifier</span> <span class="t-spar">initializer</span>
</td>
<td> (6)
</td>
<td> <span class="t-mark-rev t-since-cxx14">(C++14)</span>
</td>
</tr>



<tr>
<td colspan="10" class="t-sdsc-sep">
</td>
</tr>
<tr class="t-sdsc">
<td> <code><b>this</b></code>
</td>
<td> (7)
</td>
<td class="t-sdsc-nopad">
</td>
</tr>



<tr>
<td colspan="10" class="t-sdsc-sep">
</td>
</tr>
</table>
<div class="t-li1">
<span class="t-li">1)</span> simple by-copy capture</div>
<div class="t-li1">
<span class="t-li">2)</span> by-copy capture that is a <a href="parameter_pack.html" title="cpp/language/parameter pack">pack expansion</a>
</div>
<div class="t-li1">
<span class="t-li">3)</span> by-copy capture with an <a href="initialization.html" title="cpp/language/initialization">initializer</a>
</div>
<div class="t-li1">
<span class="t-li">4)</span> simple by-reference capture</div>
<div class="t-li1">
<span class="t-li">5)</span> by-reference capture that is a <a href="parameter_pack.html" title="cpp/language/parameter pack">pack expansion</a>
</div>
<div class="t-li1">
<span class="t-li">6)</span> by-reference capture with an initializer</div>
<div class="t-li1">
<span class="t-li">7)</span> capture for the <a href="this.html" title="cpp/language/this">this pointer</a>
</div>
<p>If a capture-default is used, no other captures may use the same capture type. Any capture may appear only once.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">struct</span> S2 <span class="br0">{</span> <span class="kw4">void</span> f<span class="br0">(</span><span class="kw4">int</span> i<span class="br0">)</span><span class="sy4">;</span> <span class="br0">}</span><span class="sy4">;</span>
<span class="kw4">void</span> S2<span class="sy4">::</span><span class="me2">f</span><span class="br0">(</span><span class="kw4">int</span> i<span class="br0">)</span> <span class="br0">{</span>
    <span class="br0">[</span><span class="sy3">&amp;</span>, i<span class="br0">]</span><span class="br0">{</span> <span class="br0">}</span><span class="sy4">;</span> <span class="co1">// OK</span>
    <span class="br0">[</span><span class="sy3">&amp;</span>, <span class="sy3">&amp;</span>i<span class="br0">]</span><span class="br0">{</span> <span class="br0">}</span><span class="sy4">;</span> <span class="co1">// error: i preceded by &amp; when &amp; is the default</span>
    <span class="br0">[</span><span class="sy1">=</span>, this<span class="br0">]</span><span class="br0">{</span> <span class="br0">}</span><span class="sy4">;</span> <span class="co1">// error: this when = is the default</span>
    <span class="br0">[</span>i, i<span class="br0">]</span><span class="br0">{</span> <span class="br0">}</span><span class="sy4">;</span> <span class="co1">// error: i repeated</span>
<span class="br0">}</span></pre></div></div>
<p>Only lambda-expressions defined at block scope may have a capture-default or captures without initializers. For such lambda-expression, the <i>reaching scope</i> is defined as the set of enclosing scopes up to and including the innermost enclosing function (and its parameters). This includes nested block scopes and the scopes of enclosing lambdas if this lambda is nested.
</p>
<p>The <span class="t-spar">identifier</span> in any capture without an initializer (other than the <code>this</code>-capture) is looked up using usual <a href="lookup.html" title="cpp/language/lookup">unqualified name lookup</a> in the <i>reaching scope</i> of the lambda. Such name is <i>explicitly captured</i>.
</p>
 <table class="t-rev-begin">
<tr class="t-rev t-since-cxx14">
<td>
<p>A capture with an initializer acts as if it declares and explicitly captures a variable declared with type <a href="auto.html" title="cpp/language/auto">auto</a>, whose declarative region is the body of the lambda expression (that is, it is not in scope within its initializer), except that:
</p>
<ul>
<li> if the capture is by-copy, the non-static data member of the closure object is another way to refer to that auto variable.
</li>
<li> if the capture is by-reference, the reference variable's lifetime ends when the lifetime of the closure object ends
</li>
</ul>
<p>This is used to capture move-only types with a capture such as <span class="t-c"><span class="mw-geshi cpp source-cpp">x <span class="sy1">=</span> <a href="../utility/move.html"><span class="kw922">std::<span class="me2">move</span></span></a><span class="br0">(</span>x<span class="br0">)</span></span></span>
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw4">int</span> x <span class="sy1">=</span> <span class="nu0">4</span><span class="sy4">;</span>
<span class="kw4">auto</span> y <span class="sy1">=</span> <span class="br0">[</span><span class="sy3">&amp;</span>r <span class="sy1">=</span> x, x <span class="sy1">=</span> x<span class="sy2">+</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">(</span><span class="br0">)</span><span class="sy2">-</span><span class="sy1">&gt;</span><span class="kw4">int</span> <span class="br0">{</span>
                r <span class="sy2">+</span><span class="sy1">=</span> <span class="nu0">2</span><span class="sy4">;</span>
                <span class="kw1">return</span> x<span class="sy2">+</span><span class="nu0">2</span><span class="sy4">;</span>
          <span class="br0">}</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// updates ::x to 6</span>
               <span class="co1">// initializes y to 7.</span></pre></div></div>
</td>
<td><span class="t-mark-rev t-since-cxx14">(since C++14)</span></td>
</tr>
</table>
<p>If a capture list has a capture-default and does not explicitly capture <code>this</code> or an automatic variable, captures it <i>implicitly</i> if
</p>
<ul><li> the body of the lambda <a href="definition.html#ODR-use" title="cpp/language/definition">odr-uses</a> the variable or <code>this</code>
</li></ul>
 <table class="t-rev-begin">
<tr class="t-rev t-since-cxx14">
<td>
<ul><li> or the variable or <code>this</code> is named in a potentially-evaluated expression within an expression that depends on a generic lambda parameter
</li></ul>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw4">void</span> f<span class="br0">(</span><span class="kw4">int</span>, <span class="kw4">const</span> <span class="kw4">int</span> <span class="br0">(</span><span class="sy3">&amp;</span><span class="br0">)</span><span class="br0">[</span><span class="nu0">2</span><span class="br0">]</span> <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span> <span class="br0">{</span> <span class="br0">}</span> <span class="co1">// #1</span>
<span class="kw4">void</span> f<span class="br0">(</span><span class="kw4">const</span> <span class="kw4">int</span><span class="sy3">&amp;</span>, <span class="kw4">const</span> <span class="kw4">int</span> <span class="br0">(</span><span class="sy3">&amp;</span><span class="br0">)</span><span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span> <span class="br0">{</span> <span class="br0">}</span> <span class="co1">// #2</span>
<span class="kw4">void</span> test<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw4">const</span> <span class="kw4">int</span> x <span class="sy1">=</span> <span class="nu0">17</span><span class="sy4">;</span>
    <span class="kw4">auto</span> g <span class="sy1">=</span> <span class="br0">[</span><span class="br0">]</span><span class="br0">(</span><span class="kw4">auto</span> a<span class="br0">)</span> <span class="br0">{</span>
                  f<span class="br0">(</span>x<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// OK: calls #1, does not capture x</span>
             <span class="br0">}</span><span class="sy4">;</span>
    <span class="kw4">auto</span> g2 <span class="sy1">=</span> <span class="br0">[</span><span class="sy1">=</span><span class="br0">]</span><span class="br0">(</span><span class="kw4">auto</span> a<span class="br0">)</span> <span class="br0">{</span>
                  <span class="kw4">int</span> selector<span class="br0">[</span>sizeof<span class="br0">(</span>a<span class="br0">)</span> <span class="sy1">==</span> <span class="nu0">1</span> <span class="sy4">?</span> <span class="nu0">1</span> <span class="sy4">:</span> <span class="nu0">2</span><span class="br0">]</span><span class="br0">{</span><span class="br0">}</span><span class="sy4">;</span>
                  f<span class="br0">(</span>x, selector<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// OK: is a dependent expression, so captures x</span>
             <span class="br0">}</span><span class="sy4">;</span>
<span class="br0">}</span></pre></div></div>
</td>
<td><span class="t-mark-rev t-since-cxx14">(since C++14)</span></td>
</tr>
</table>
<p>If the body of a lambda <a href="definition.html#ODR-use" title="cpp/language/definition">odr-uses</a> an entity captured by copy, the member of the closure type is accessed. If it is not odr-using the entity, the access is to the original object:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw4">void</span> f<span class="br0">(</span><span class="kw4">const</span> <span class="kw4">int</span><span class="sy2">*</span><span class="br0">)</span><span class="sy4">;</span>
<span class="kw4">void</span> g<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw4">const</span> <span class="kw4">int</span> N <span class="sy1">=</span> <span class="nu0">10</span><span class="sy4">;</span>
    <span class="br0">[</span><span class="sy1">=</span><span class="br0">]</span> <span class="br0">{</span> 
        <span class="kw4">int</span> arr<span class="br0">[</span>N<span class="br0">]</span><span class="sy4">;</span> <span class="co1">// not an odr-use: refers to g's const int N</span>
        f<span class="br0">(</span><span class="sy3">&amp;</span>N<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// odr-use: causes N to be captured (by copy)</span>
               <span class="co1">// &amp;N is the address of the closure object's member N, not g's N</span>
    <span class="br0">}</span><span class="sy4">;</span>
<span class="br0">}</span></pre></div></div>
<p>Within the body of a lambda, any use of <a href="decltype.html" title="cpp/language/decltype">decltype</a> on any variable with automatic storage duration is as if it were captured and odr-used, even though decltype itself isn't an odr-use and no actual capture takes place:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw4">void</span> f3<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw4">float</span> x, <span class="sy3">&amp;</span>r <span class="sy1">=</span> x<span class="sy4">;</span>
    <span class="br0">[</span><span class="sy1">=</span><span class="br0">]</span> <span class="br0">{</span> <span class="co1">// x and r are not captured (appearance in a decltype operand is not an odr-use)</span>
        decltype<span class="br0">(</span>x<span class="br0">)</span> y1<span class="sy4">;</span> <span class="co1">// y1 has type float</span>
        decltype<span class="br0">(</span><span class="br0">(</span>x<span class="br0">)</span><span class="br0">)</span> y2 <span class="sy1">=</span> y1<span class="sy4">;</span> <span class="co1">// y2 has type float const&amp; because this lambda</span>
                               <span class="co1">// is not mutable and x is an lvalue</span>
        decltype<span class="br0">(</span>r<span class="br0">)</span> r1 <span class="sy1">=</span> y1<span class="sy4">;</span>   <span class="co1">// r1 has type float&amp; (transformation not considered)</span>
        decltype<span class="br0">(</span><span class="br0">(</span>r<span class="br0">)</span><span class="br0">)</span> r2 <span class="sy1">=</span> y2<span class="sy4">;</span> <span class="co1">// r2 has type float const&amp;</span>
    <span class="br0">}</span><span class="sy4">;</span>
<span class="br0">}</span></pre></div></div>
<p>Any entity captured by a lambda (implicitly or explicitly) is odr-used by the lambda-expression (therefore, Implicit capture by a nested lambda triggers implicit capture in the enclosing lambda).
</p>
<p>All implicitly-captured variables must be declared within the <i>reaching scope</i> of the lambda.
</p>
<p>If a lambda captures <code>this</code>, the nearest enclosing function must be a non-static member function.
</p>
<p>If a generic lambda (or an instantiation of a generic capture-less lambda's conversion operator) ODR-uses <code>this</code> or any variable, it is captured by the lambda expression.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw4">void</span> f1<span class="br0">(</span><span class="kw4">int</span> i<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw4">int</span> <span class="kw4">const</span> N <span class="sy1">=</span> <span class="nu0">20</span><span class="sy4">;</span>
    <span class="kw4">auto</span> m1 <span class="sy1">=</span> <span class="br0">[</span><span class="sy1">=</span><span class="br0">]</span><span class="br0">{</span>
            <span class="kw4">int</span> <span class="kw4">const</span> M <span class="sy1">=</span> <span class="nu0">30</span><span class="sy4">;</span>
            <span class="kw4">auto</span> m2 <span class="sy1">=</span> <span class="br0">[</span>i<span class="br0">]</span><span class="br0">{</span>
                  <span class="kw4">int</span> x<span class="br0">[</span>N<span class="br0">]</span><span class="br0">[</span>M<span class="br0">]</span><span class="sy4">;</span> <span class="co1">// N and M are not odr-used (OK that they are not captured)</span>
                  x<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy1">=</span> i<span class="sy4">;</span> <span class="co1">// i is explicitly captured by m2</span>
                               <span class="co1">// and implicitly captured by m1</span>
            <span class="br0">}</span><span class="sy4">;</span>
     <span class="br0">}</span><span class="sy4">;</span>
 
    <span class="kw1">struct</span> s1 <span class="br0">{</span> <span class="co1">// local class within f()</span>
        <span class="kw4">int</span> f<span class="sy4">;</span>
        <span class="kw4">void</span> work<span class="br0">(</span><span class="kw4">int</span> n<span class="br0">)</span> <span class="br0">{</span> <span class="co1">// non-static member function</span>
            <span class="kw4">int</span> m <span class="sy1">=</span> n<span class="sy2">*</span>n<span class="sy4">;</span>
            <span class="kw4">int</span> j <span class="sy1">=</span> <span class="nu0">40</span><span class="sy4">;</span>
            <span class="kw4">auto</span> m3 <span class="sy1">=</span> <span class="br0">[</span>this,m<span class="br0">]</span> <span class="br0">{</span>
                <span class="kw4">auto</span> m4 <span class="sy1">=</span> <span class="br0">[</span><span class="sy3">&amp;</span>,j<span class="br0">]</span> <span class="br0">{</span> <span class="co1">// error: j not captured by m3</span>
                    <span class="kw4">int</span> x <span class="sy1">=</span> n<span class="sy4">;</span> <span class="co1">// error: n implicitly captured by m4</span>
                               <span class="co1">// but not captured by m3</span>
                    x <span class="sy2">+</span><span class="sy1">=</span> m<span class="sy4">;</span> <span class="co1">// OK: m implicitly captured by m4</span>
                            <span class="co1">// and explicitly captured by m3</span>
                    x <span class="sy2">+</span><span class="sy1">=</span> i<span class="sy4">;</span> <span class="co1">// error: i is outside of the reaching scope (which ends at work())</span>
                    x <span class="sy2">+</span><span class="sy1">=</span> f<span class="sy4">;</span> <span class="co1">// OK: this captured implicitly by m4</span>
                            <span class="co1">// and explicitly by m3</span>
                <span class="br0">}</span><span class="sy4">;</span>
            <span class="br0">}</span><span class="sy4">;</span>
       <span class="br0">}</span>
    <span class="br0">}</span><span class="sy4">;</span>
<span class="br0">}</span></pre></div></div>
<p>If a lambda-expression appears in a <a href="default_arguments.html" title="cpp/language/default arguments">default argument</a>, it cannot explicitly or implicitly capture anything.
</p>
<p>Members of <a href="union.html" title="cpp/language/union">anonymous unions</a> cannot be captured.
</p>
<p>If a nested lambda <code>m2</code> captures something that is also captured by the immediately enclosing lambda <code>m1</code>, then <code>m2</code>'s capture is transformed as follows:
</p>
<ul>
<li> if the enclosing lambda <code>m1</code> captures by copy, <code>m2</code> is capturing the non-static member of <code>m1</code>'s closure type, not the original variable or <code>this</code>.
</li>
<li> if the enclosing lambda <code>m1</code> by reference, <code>m2</code> is capturing the original variable or <code>this</code>.
</li>
</ul>
<div class="t-example">
<div class="t-example-live-link"><div class="coliru-btn coliru-btn-run-init">Run this code</div></div>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="co2">#include &lt;iostream&gt;</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span> 
<span class="br0">{</span>
    <span class="kw4">int</span> a <span class="sy1">=</span> <span class="nu0">1</span>, b <span class="sy1">=</span> <span class="nu0">1</span>, c <span class="sy1">=</span> <span class="nu0">1</span><span class="sy4">;</span>
    <span class="kw4">auto</span> m1 <span class="sy1">=</span> <span class="br0">[</span>a, <span class="sy3">&amp;</span>b, <span class="sy3">&amp;</span>c<span class="br0">]</span><span class="br0">(</span><span class="br0">)</span> mutable <span class="br0">{</span> 
      <span class="kw4">auto</span> m2 <span class="sy1">=</span> <span class="br0">[</span>a, b, <span class="sy3">&amp;</span>c<span class="br0">]</span><span class="br0">(</span><span class="br0">)</span> mutable <span class="br0">{</span>
        <a href="../io/cout.html"><span class="kw1453">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> a <span class="sy1">&lt;&lt;</span> b <span class="sy1">&lt;&lt;</span> c<span class="sy4">;</span>
        a <span class="sy1">=</span> <span class="nu0">4</span><span class="sy4">;</span> b <span class="sy1">=</span> <span class="nu0">4</span><span class="sy4">;</span> c <span class="sy1">=</span> <span class="nu0">4</span><span class="sy4">;</span>
      <span class="br0">}</span><span class="sy4">;</span>
      a <span class="sy1">=</span> <span class="nu0">3</span><span class="sy4">;</span> b <span class="sy1">=</span> <span class="nu0">3</span><span class="sy4">;</span> c <span class="sy1">=</span> <span class="nu0">3</span><span class="sy4">;</span>
      m2<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> 
    <span class="br0">}</span><span class="sy4">;</span>
    a <span class="sy1">=</span> <span class="nu0">2</span><span class="sy4">;</span> b <span class="sy1">=</span> <span class="nu0">2</span><span class="sy4">;</span> c <span class="sy1">=</span> <span class="nu0">2</span><span class="sy4">;</span>
    m1<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>                     <span class="co1">// calls m2() and prints 123</span>
    <a href="../io/cout.html"><span class="kw1453">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> a <span class="sy1">&lt;&lt;</span> b <span class="sy1">&lt;&lt;</span> c<span class="sy4">;</span> <span class="co1">// prints 234</span>
<span class="br0">}</span></pre></div></div>
<p><br> 
</p>
</div>
<table class="metadata plainlinks ambox mbox-small-left ambox-notice" style=""><tr>
<td class="mbox-empty-cell"></td>
<td class="mbox-text" style="">This section is incomplete<br>Reason: consider rearranging the layout for readability </td>
</tr></table>
<h3>
<span class="editsection">[<a href="http%3A//en.cppreference.com/mwiki/index.php" title="Edit section: Example">edit</a>]</span> <span class="mw-headline" id="Example">Example</span>
</h3>
<div class="t-example">
<p> This example shows (a) how to pass a lambda to a generic algorithm and (b) how objects resulting from a lambda declaration can be stored in <span class="t-lc"><a href="../utility/functional/function.html" title="cpp/utility/functional/function">std::function</a></span> objects.
 </p>
<div class="t-example-live-link"><div class="coliru-btn coliru-btn-run-init">Run this code</div></div>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="co2">#include &lt;vector&gt;</span>
<span class="co2">#include &lt;iostream&gt;</span>
<span class="co2">#include &lt;algorithm&gt;</span>
<span class="co2">#include &lt;functional&gt;</span>
 
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <a href="../container/vector.html"><span class="kw1071">std::<span class="me2">vector</span></span></a><span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> c <span class="br0">{</span> <span class="nu0">1</span>,<span class="nu0">2</span>,<span class="nu0">3</span>,<span class="nu0">4</span>,<span class="nu0">5</span>,<span class="nu0">6</span>,<span class="nu0">7</span> <span class="br0">}</span><span class="sy4">;</span>
    <span class="kw4">int</span> x <span class="sy1">=</span> <span class="nu0">5</span><span class="sy4">;</span>
    c.<span class="me1">erase</span><span class="br0">(</span><a href="../algorithm/remove.html"><span class="kw1298">std::<span class="me2">remove_if</span></span></a><span class="br0">(</span>c.<span class="me1">begin</span><span class="br0">(</span><span class="br0">)</span>, c.<span class="me1">end</span><span class="br0">(</span><span class="br0">)</span>, <span class="br0">[</span>x<span class="br0">]</span><span class="br0">(</span><span class="kw4">int</span> n<span class="br0">)</span> <span class="br0">{</span> <span class="kw1">return</span> n <span class="sy1">&lt;</span> x<span class="sy4">;</span> <span class="br0">}</span> <span class="br0">)</span>, c.<span class="me1">end</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy4">;</span>
 
    <a href="../io/cout.html"><span class="kw1453">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="st0">"c: "</span><span class="sy4">;</span>
    <span class="kw1">for</span> <span class="br0">(</span><span class="kw4">auto</span> i<span class="sy4">:</span> c<span class="br0">)</span> <span class="br0">{</span>
        <a href="../io/cout.html"><span class="kw1453">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> i <span class="sy1">&lt;&lt;</span> <span class="st0">' '</span><span class="sy4">;</span>
    <span class="br0">}</span>
    <a href="../io/cout.html"><span class="kw1453">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="st0">'<span class="es1">\n</span>'</span><span class="sy4">;</span>
 
    <span class="co1">// the type of a closure cannot be named, but can be inferred with auto</span>
    <span class="kw4">auto</span> func1 <span class="sy1">=</span> <span class="br0">[</span><span class="br0">]</span><span class="br0">(</span><span class="kw4">int</span> i<span class="br0">)</span> <span class="br0">{</span> <span class="kw1">return</span> i<span class="sy2">+</span><span class="nu0">4</span><span class="sy4">;</span> <span class="br0">}</span><span class="sy4">;</span>
    <a href="../io/cout.html"><span class="kw1453">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="st0">"func1: "</span> <span class="sy1">&lt;&lt;</span> func1<span class="br0">(</span><span class="nu0">6</span><span class="br0">)</span> <span class="sy1">&lt;&lt;</span> <span class="st0">'<span class="es1">\n</span>'</span><span class="sy4">;</span> 
 
    <span class="co1">// like all callable objects, closures can be captured in std::function</span>
    <span class="co1">// (this may incur unnecessary overhead)</span>
    <a href="../utility/functional/function.html"><span class="kw899">std::<span class="me2">function</span></span></a><span class="sy1">&lt;</span><span class="kw4">int</span><span class="br0">(</span><span class="kw4">int</span><span class="br0">)</span><span class="sy1">&gt;</span> func2 <span class="sy1">=</span> <span class="br0">[</span><span class="br0">]</span><span class="br0">(</span><span class="kw4">int</span> i<span class="br0">)</span> <span class="br0">{</span> <span class="kw1">return</span> i<span class="sy2">+</span><span class="nu0">4</span><span class="sy4">;</span> <span class="br0">}</span><span class="sy4">;</span>
    <a href="../io/cout.html"><span class="kw1453">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="st0">"func2: "</span> <span class="sy1">&lt;&lt;</span> func2<span class="br0">(</span><span class="nu0">6</span><span class="br0">)</span> <span class="sy1">&lt;&lt;</span> <span class="st0">'<span class="es1">\n</span>'</span><span class="sy4">;</span> 
<span class="br0">}</span></pre></div></div>
<p>Output:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="text source-text"><pre class="de1">c: 5 6 7
func1: 10
func2: 10</pre></div></div> 
</div>
<h3>
<span class="editsection">[<a href="http%3A//en.cppreference.com/mwiki/index.php" title="Edit section: See also">edit</a>]</span> <span class="mw-headline" id="See_also">See also</span>
</h3>
<table class="t-dsc-begin">

<tr class="t-dsc">
<td>  <a href="auto.html" title="cpp/language/auto"> auto specifier </a>
</td>
<td>  specifies a type defined by an expression <span class="t-mark-rev t-since-cxx11">(C++11)</span> 
</td>
</tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div">
<div><a href="../utility/functional/function.html" title="cpp/utility/functional/function"> <span class="t-lines"><span>function</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div>
</div>
</td>
<td>   wraps callable object of any type with specified function call signature  <br> <span class="t-mark">(class template)</span> 
</td>
</tr>
</table>

<!-- 
NewPP limit report
Preprocessor visited node count: 4802/1000000
Preprocessor generated node count: 13109/1000000
Post‐expand include size: 77316/2097152 bytes
Template argument size: 37142/2097152 bytes
Highest expansion depth: 20/40
Expensive parser function count: 0/100
-->

<!-- Saved in parser cache with key mwiki1-mwiki_en_:pcache:idhash:5059-0!*!0!!en!*!* and timestamp 20150731174356 -->
</div>                    <!-- /bodycontent -->
                                        <!-- printfooter -->
                    <div class="printfooter">
                    Retrieved from "<a href="http%3A//en.cppreference.com/mwiki/index.php">http://en.cppreference.com/mwiki/index.php?title=cpp/language/lambda&amp;oldid=80200</a>"                    </div>
                    <!-- /printfooter -->
                                                            <!-- catlinks -->
                    <div id="catlinks" class="catlinks"><div id="mw-normal-catlinks" class="mw-normal-catlinks">
<a href="http%3A//en.cppreference.com/w/Special%3ACategories" title="Special:Categories">Category</a>: <ul><li><a href="http%3A//en.cppreference.com/w/Category%3ATodo_with_reason" title="Category:Todo with reason">Todo with reason</a></li></ul>
</div></div>                    <!-- /catlinks -->
                                                            <div class="visualClear"></div>
                    <!-- debughtml -->
                                        <!-- /debughtml -->
                </div>
                <!-- /bodyContent -->
            </div>
        </div>
        <!-- /content -->
        <!-- footer -->
        
        <!-- /footer -->
        <script>if(window.mw){
mw.loader.state({"site":"loading","user":"missing","user.groups":"ready"});
}</script>
<script src="../../../common/skin_scripts.js"></script>
<script>if(window.mw){
mw.loader.load(["mediawiki.action.view.postEdit","mediawiki.user","mediawiki.page.ready","mediawiki.searchSuggest","mediawiki.hidpi","ext.gadget.ColiruCompiler"], null, true);
}</script>
<script src="../../../common/site_scripts.js"></script>

<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-2828341-1']);
_gaq.push(['_setDomainName', 'cppreference.com']);
_gaq.push(['_trackPageview']);
</script><!-- Served in 0.084 secs. -->
	</body>
<!-- Cached 20150731174457 -->
</html>
